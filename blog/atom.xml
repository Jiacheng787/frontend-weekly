<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://your-docusaurus-test-site.com/frontend-weekly/blog</id>
    <title>Frontend Weekly Blog</title>
    <updated>2022-12-12T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://your-docusaurus-test-site.com/frontend-weekly/blog"/>
    <subtitle>Frontend Weekly Blog</subtitle>
    <icon>https://your-docusaurus-test-site.com/frontend-weekly/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[置顶内容]]></title>
        <id>welcome</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/welcome"/>
        <updated>2022-12-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[⭐️ 每周更新优质技术文章，欢迎点赞关注！]]></summary>
        <content type="html"><![CDATA[<p>⭐️ 每周更新优质技术文章，欢迎点赞关注！</p><h2>TypeScript 工程化方案</h2><ul><li>⭐️ ⭐️ <a href="https://zhuanlan.zhihu.com/p/403970666">2021 年 TypeScript + React 工程化指南</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/7039583726375796749#heading-22">会写 TypeScript 但你真的会 TS 编译配置吗？</a></li><li>🌛 <a href="https://juejin.cn/post/6844904102355271694">【开源】一个 React + TS 项目模板</a><ul><li>一种是使用 ts-loader + babel-loader + fork-ts-checker-webpack-plugin 通过 typescript 进行编译和类型检查</li><li>另一种是 babel-loader + @babel/preset-typescript 使用 babel 进行编译，typescript 只负责类型检查（babel 7 以上）</li></ul></li><li>🌛 <a href="https://juejin.cn/post/6999807899149008910">2021年从零开发前端项目指南</a></li><li><a href="https://juejin.cn/post/6844904052094926855">Webpack 转译 Typescript 现有方案</a></li><li>🌛 <a href="https://segmentfault.com/a/1190000015315545">使用ESLint+Prettier来统一前端代码风格</a></li><li>🌛 <a href="https://segmentfault.com/a/1190000009546913">用 husky 和 lint-staged 构建超溜的代码检查工作流</a></li></ul><h2>TS 高级技巧</h2><ul><li>🌛 <a href="https://mp.weixin.qq.com/s/TUv8Cu6_ftQQ6lEWAwIa4w">TypeScript 类型系统：分布式条件类型全解</a></li><li>🌛 <a href="https://juejin.cn/post/7061556434692997156">接近天花板的TS类型体操，看懂你就能玩转TS了</a></li><li>🌛 <a href="https://mp.weixin.qq.com/s/-x8iVK-hlQd3-OZDC04A5A">TypeScript 类型编程: 从基础到编译器实战</a></li><li>🌛 <a href="https://juejin.cn/post/7050099282317148174">知其然，知其所以然：TypeScript 中的协变与逆变</a></li><li>🌛 <a href="https://juejin.cn/post/7007251289721536543">TypeScript是如何工作的</a></li><li>⭐️ <a href="https://juejin.cn/post/6964692485415108645">TypeScript 高级用法</a></li><li><a href="https://juejin.cn/post/6844904055039344654">TS 常见问题整理（60多个，持续更新ing）</a></li><li><a href="https://juejin.cn/post/6994102811218673700">Ts高手篇：22个示例深入讲解Ts最晦涩难懂的高级类型工具</a></li></ul><h2>TS &amp;&amp; 框架</h2><ul><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6952696734078369828">React + TypeScript实践</a></li><li><a href="https://juejin.cn/post/7021674818621669389">如何优雅地在 React 中使用TypeScript，看这一篇就够了！</a></li><li>⭐️ <a href="https://juejin.cn/post/6844903865255477261">Vue3.0 前的 TypeScript 最佳入门实践</a><ul><li>虽然不是 Vue3 但是也推荐看下</li></ul></li></ul><h2>前端框架</h2><ul><li><a href="https://juejin.cn/post/7047705995534925832">盘点掘金 2021 高赞 Vue 文章</a></li><li><a href="https://juejin.cn/post/7047690546417565733">盘点掘金 2021 高赞 React 文章</a></li><li><a href="https://juejin.cn/post/7047153016771706916">盘点掘金 2021 点赞高达 6000，收藏过万的文章</a></li><li>⭐️ <a href="https://juejin.cn/post/6922641008106668045">揭秘 Vue.js 九个性能优化技巧</a></li><li>🌛 <a href="https://juejin.cn/post/7005880217684148231">我在项目中用实际用到的22个Vue优化技巧</a></li><li>🌛 <a href="https://juejin.cn/post/7046358484610187277">React Hooks 使用误区，驳官方文档</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/7043772161596588046">宝啊～来聊聊 9 种 React Hook</a></li><li>⭐️ <a href="https://juejin.cn/post/6933018383961194509">你可能不知道的流式 React Hooks（关于组织代码的最佳实践）</a></li><li>⭐️ <a href="https://juejin.cn/post/7025524870842679310#heading-58">从 16 个方向逐步搭建基于 vue3 的前端架构</a></li><li>⭐️ <a href="https://juejin.cn/post/6874007172578033677">34条我能告诉你的Vue之实操篇</a></li><li>🌛 <a href="https://zhuanlan.zhihu.com/p/461844358">React 体系下关于 Mobx 与 Redux 的一些思考</a></li><li>🌛 <a href="https://mp.weixin.qq.com/s/aOapwk4_qi8tNM7vaa7jGA">使用 React&amp;Mobx 的几个最佳实践</a></li><li>⭐️ <a href="https://juejin.cn/post/6995834232350179336">当设计模式遇上 Hooks</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6844903985338400782">React Hooks 详解 【近 1W 字】+ 项目实战</a></li><li><a href="https://juejin.cn/post/6989022564043456543">「React进阶」只用两个自定义 Hooks 就能替代 React-Redux ?</a></li><li><a href="https://juejin.cn/post/6950063294270930980">「React进阶」 React全部api解读+基础实践大全(夯实基础2万字总结)</a></li><li><a href="https://juejin.cn/post/6963053793613185031">「React进阶」探案揭秘六种React‘灵异’现象</a></li><li><a href="https://juejin.cn/post/6944863057000529933">「react进阶」一文吃透react-hooks原理</a></li></ul><h2>开源项目</h2><ul><li>⭐️ <a href="https://github.com/streamich/react-use">react-use - 一个 React Hooks 库</a></li><li><a href="https://github.com/tannerlinsley/react-query">react-query - 用于获取数据、缓存、异步更新状态的 hook</a></li><li><a href="https://github.com/prisma/prisma">prisma - 下一代 Nodejs ORM 工具，支持各种数据库</a></li><li><a href="https://github.com/withastro/astro">astro - 静态站点构建工具</a></li><li><a href="https://github.com/pmndrs/zustand">zustand - 小型、快速可扩展的状态管理解决方案</a></li><li><a href="https://github.com/tauri-apps/tauri">tauri - 将前端项目打包为桌面应用，用于替代 electron</a></li></ul><h2>业务成长</h2><ul><li>⭐️ <a href="https://juejin.cn/post/6965675185890394119">精读《前端职业规划 - 2021 年》</a></li><li>⭐️ <a href="https://juejin.cn/post/7034419410706104356">2022年如何成为一名优秀的大前端Leader？</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6906468062943182862#heading-8">初级工程师如何快速成长和寻求突破</a></li><li><a href="https://mp.weixin.qq.com/s/NRqhJax8e6K8LMCNZSSozA">年底了，你是如何做工作汇报的？</a></li><li>⭐️ <a href="https://juejin.cn/post/6844904103504527374">写给初中级前端的高级进阶指南</a></li><li><a href="https://juejin.cn/post/7041713124210114567">在政采云如何写前端技术方案文档</a></li><li><a href="https://juejin.cn/post/7017643726944108558">如何编写前端设计文档</a></li><li>⭐️ <a href="https://juejin.cn/post/6901845776880795662#heading-0">理清思路，前端技术调研到底应该怎么做？</a></li><li><a href="https://juejin.cn/post/6869548364640288781">从实习到入职：与你分享我在政采云的工作和成长</a></li></ul><h2>Git 相关</h2><ul><li><a href="https://juejin.cn/post/7046409685561245733">利用好 git bisect 这把利器，帮助你快速定位疑难 bug</a></li><li>⭐️ <a href="https://juejin.cn/post/7024043015794589727">前端架构师的 git 功力，你有几成火候？</a></li><li>⭐️ <a href="https://segmentfault.com/a/1190000040712052">两条命令让你的git自动变基</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6844904191203213326">多年 Git 使用心得 &amp; 常见问题整理</a></li><li>🌛 <a href="https://juejin.cn/post/7000186205224566791">为什么 husky 放弃了传统的 JS 配置</a></li><li>⭐️ <a href="https://juejin.cn/post/6844904036068491278">你可能已经忽略的git commit规范</a></li><li><a href="https://gitmoji.dev/">gitmoji: An emoji guide for your commit messages</a></li></ul><h2>源码系列</h2><ul><li>⭐️ <a href="https://juejin.cn/post/6982004709145968677">[建议收藏] 你想知道的Vue3核心源码这里都有</a></li><li>⭐️ <a href="https://juejin.cn/post/7048970987500470279">六千字详解！vue3 响应式是如何实现的？</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/7019185205336342542">Redux通关简洁攻略 -- 看这一篇就够了！</a></li><li>⭐️ <a href="https://juejin.cn/post/6978654109893132318">手写系列-实现一个铂金段位的 React</a></li><li>⭐️ <a href="https://juejin.cn/post/7010539227284766751">React 运行时优化方案的演进</a></li><li>⭐️ <a href="https://juejin.cn/post/6990974525273800712">带你快速手写一个简易版vue了解vue响应式</a></li><li><a href="https://juejin.cn/post/6977363265965785102">2021年，让我们手写一个mini版本的vue2.x和vue3.x框架</a></li><li><a href="https://juejin.cn/post/6846687602679119885">Vue(v2.6.11)万行源码生啃，就硬刚！</a></li><li><a href="https://juejin.cn/post/6992018709439053837">尤雨溪国外教程：亲手带你写个简易版的Vue！</a></li><li><a href="https://codepen.io/collection/DkxpbE?cursor=ZD0wJm89MCZwPTEmdj00">Vue 3 Workshop Code Samples</a></li><li>⭐️ <a href="https://juejin.cn/post/6997965021401579556">diff 算法深入一下？</a></li><li>⭐️ <a href="https://juejin.cn/post/6997943192851054606">Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？</a></li><li>⭐️ <a href="https://juejin.cn/post/6994976281053888519">初学者也能看懂的 Vue3 源码中那些实用的基础工具函数</a></li></ul><h2>Webpack 系列</h2><ul><li><a href="https://juejin.cn/post/6937125495439900685">Webpack 案例 —— vue-loader 原理分析</a><ul><li>通过编写一个 plugin，在预处理阶段通过插件 apply 函数动态修改 webpack 配置，注入 vue-loader 专用的 rules</li></ul></li><li>⭐️ <a href="https://juejin.cn/post/7047777251949019173">超硬核｜带你畅游在 Webpack 插件开发者的世界</a></li><li>⭐️ <a href="https://juejin.cn/post/7031546400034947108">Webapck5核心打包原理全流程解析</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/7023242274876162084">【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系</a></li><li>⭐️ <a href="https://juejin.cn/post/7021729340945596424">Webpack 原理系列十：HMR 原理全解析</a></li><li><a href="https://mp.weixin.qq.com/s/gwHwVxA4zh59SBvq-onM-g">Webpack5 实践 - 构建效率倍速提升！</a></li><li>🌛 <a href="https://mp.weixin.qq.com/s/mpF6W-4dElu0UPed03oJQw">Webpack 性能系列一: 使用 Cache 提升构建性能</a></li><li>🌛 <a href="https://juejin.cn/post/6910893471339708429">我是如何将网页性能提升5倍的 — 构建优化篇</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6996816316875161637">学习 Webpack5 之路（优化篇）- 近 7k 字</a></li><li>⭐️ <a href="https://juejin.cn/post/6844903912588181511">手把手带你入门 Webpack4</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6949040393165996040">[<!-- -->万字总结<!-- -->]<!-- --> 一文吃透 Webpack 核心原理</a></li></ul><h2>Vite 系列</h2><ul><li><a href="https://juejin.cn/post/6979932627465666568">下一代前端构建工具 - Vite 2.x 源码级分析</a></li><li><a href="https://juejin.cn/post/6956564266812571656">面向未来的前端构建工具 - Vite ⚡️原理分析</a></li></ul><h2>Monorepo 系列</h2><ul><li><a href="https://juejin.cn/post/7051929587852247077">年终盘点：2022基于Monorepo的首个大趋势-TurboRepo</a></li><li><a href="https://juejin.cn/post/7043998041786810398">One For All：基于pnpm + lerna + typescript的最佳项目实践 - 理论篇</a></li><li><a href="https://juejin.cn/post/7029262501833359368">【我要做开源】Vue DevUI开源指南08：Monorepo改造</a></li><li><a href="https://juejin.cn/post/6972139870231724045">Monorepo 的这些坑，我们帮你踩过了！</a></li></ul><h2>Rollup 系列</h2><ul><li><a href="https://juejin.cn/post/7052307032971411463">从零开始发布自己的NPM包</a></li><li><a href="https://juejin.cn/post/6844903970469576718">前端组件/库打包利器rollup使用与配置实战</a></li><li><a href="https://juejin.cn/post/6869551115420041229">一文带你快速上手Rollup</a></li></ul><h2>前端工程化</h2><ul><li>⭐️ <a href="https://juejin.cn/post/7062617190981173278">来自未来，2022 年的前端人都在做什么?</a></li><li><a href="https://juejin.cn/post/7056612950412361741">为什么说 WebAssembly 是 Web 的未来？</a></li><li><a href="https://juejin.cn/post/7057114641507287048">easy-serverless 功能分析</a></li><li>🌛 <a href="https://mp.weixin.qq.com/s/QCIlheiEgmU4Qi-4b_XoqQ">用DDD(领域驱动设计)和ADT(代数数据类型)提升代码质量</a></li><li>⭐️ <a href="https://juejin.cn/post/7046204235226021901">基于 Next.js 的 SSR/SSG 方案了解一下？</a></li><li>🌛 <a href="https://juejin.cn/post/7029512357428592648">前端架构师神技，三招统一团队代码风格</a></li><li>🌛 <a href="https://juejin.cn/post/6844904110601273357">手把手教你搭建一个灰度发布环境</a></li><li>⭐️ <a href="https://juejin.cn/post/7049696761858195486">ES6 以上版本代码要不要转码成 ES5 ?</a></li><li>⭐️ <a href="https://mp.weixin.qq.com/s/3TKcUeoyzXvH3MGVI6Dj9A">ESM 与 CJS 的 Interop 来世今生</a></li><li>⭐️ <a href="https://www.zhihu.com/question/493891614/answer/2269197391">2022 前端技术领域会有哪些新的变化？</a></li><li>🌛 <a href="https://segmentfault.com/a/1190000040496020">前端构建这十年</a></li></ul><h2>持续集成</h2><ul><li><a href="https://juejin.cn/post/7064906701941506061">GitLab CI 从入门到实践</a></li><li><a href="https://www.youtube.com/watch?v=fqMOX6JJhGo">Docker Tutorial for Beginners - A Full DevOps Course on How to Run Applications in Containers</a></li><li>⭐️ <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></li><li>⭐️ <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a></li><li><a href="https://juejin.cn/post/6844903793348329486">如何使用 docker 部署前端应用</a></li><li><a href="https://shanyue.tech/op/docker.html">docker 简易入门 - shanyue</a></li><li><a href="https://mp.weixin.qq.com/s/4aFJ7t37IwEMyq-u09Wf1g">小鲸鱼的前世今生--Docker</a></li><li><a href="https://juejin.cn/book/6844733746462064654/section/6844733746504007693">开发者必备的 Docker 实践指南</a></li><li><a href="https://mp.weixin.qq.com/s/U-zK6JEMpmK2Il68-ijcaw">谁说前端不需要学习docker？</a></li><li><a href="https://juejin.cn/post/7028222480326066213">使用Docker Compose、Nginx、SSH和Github Actions实现前端自动化部署测试机</a></li><li><a href="https://juejin.cn/post/6951684431597797389">前端开发者应该知道的 Centos/Docker/Nginx/Node/Jenkins 操作(🍡 长文)</a></li><li><a href="https://juejin.cn/post/7049920990351982628">保姆级指南：jekins+docker构建部署react项目实战</a></li><li><a href="https://juejin.cn/post/6993951401952935972">你的第一个 Docker + React + Express 全栈应用</a></li></ul><h2>服务端相关</h2><ul><li>⭐️ ⭐️ <a href="https://zhuanlan.zhihu.com/p/469102289">Redis详细入门教程</a></li><li>⭐️ <a href="https://mp.weixin.qq.com/s/hJHMlbQpANwMjx9BetwkUg">一致性哈希算法解决的问题</a></li><li><a href="https://mp.weixin.qq.com/s/l3l9d9sLiWoUM381E9o-3Q">解决了 Redis 大 key 问题，同事们都说牛皮！</a></li><li><a href="https://mp.weixin.qq.com/s/l_YdpyHht5Ayvrc7LFZNIA">图解|Linux内存背后的那些神秘往事</a></li><li><a href="https://juejin.cn/post/7064952956201730062">图解|什么是内容分发网络(cdn)</a></li><li><a href="https://juejin.cn/post/7070683049049980941">一键部署 K8S 环境，10分钟玩转，这款开源神器实在太香了！</a></li><li><a href="https://mp.weixin.qq.com/s/KIcn2TAwY58JGoWiz82Q2g">颜值爆表！Redis 官方可视化工具来啦，功能真心强大！</a></li><li><a href="https://juejin.cn/post/7064378702779891749">前端到底用nginx来做啥</a></li><li><a href="https://juejin.cn/post/7048952689601806366">一份简单够用的 Nginx Location 配置讲解</a></li></ul><h2>前端性能优化</h2><ul><li>⭐️ <a href="https://juejin.cn/post/6981673766178783262">写给中高级前端关于性能优化的9大策略和6大指标 | 网易四年实践</a></li><li>⭐️ <a href="https://juejin.cn/post/7052918009555320839">最全的前端性能定位总结</a></li><li>⭐️ <a href="https://juejin.cn/post/7016900744695513125">字节跳动是如何落地微前端的</a></li><li>⭐️ <a href="https://juejin.cn/post/7048260643589193765">2022 年的 CSS</a></li><li>⭐️ <a href="https://juejin.cn/post/7054931603323093022">如何编写防御式的 CSS</a></li><li>⭐️ <a href="https://zhuanlan.zhihu.com/p/396010993">前端 Code Review 不完全指北(万字长文，50+case)</a></li><li>🌛 <a href="https://juejin.cn/post/7020212914020302856">写在 2021 的前端性能优化指南</a></li><li><a href="https://juejin.cn/post/7000728875676205086">深入浅出 Performance 工具 &amp; API</a></li><li><a href="https://juejin.cn/post/6904582930174705677">使用 Performance 看看浏览器在做什么</a></li></ul><h2>前端组件库实战</h2><ul><li>⭐️ <a href="https://juejin.cn/post/7021528826798669854">尤大都推荐的组件库是如何开发出来的？</a></li><li>⭐️ <a href="https://juejin.cn/post/6983854006124675108">每个前端都值得拥有自己的组件库，就像每个夏天都拥有西瓜🍉</a></li><li>⭐️ <a href="https://juejin.cn/post/6930879590554402830">Vue3组件库工程化实战 --Element3</a></li></ul><h2>Node.js 系列</h2><ul><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6887961766170066951">大厂是如何用DevCloud流水线实现自动化部署Web应用的？</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6902659492161421325">手把手教你使用Rollup打包 📦 并发布自己的工具库 🔧</a></li><li>🌛 <a href="https://zhuanlan.zhihu.com/p/461945753">Node 案发现场揭秘 —— 未定义 “window” 对象引发的 SSR 内存泄露</a></li><li>🌛 <a href="https://cnodejs.org/topic/58eb5d378cda07442731569f">轻松排查线上Node内存泄漏问题</a></li><li>🌛 <a href="https://mp.weixin.qq.com/s/xCoTeyJDifi4Ymk0VsI2Ig">浅谈 Node.js 热更新</a></li><li>⭐️ <a href="https://juejin.cn/post/7044344538969669663">NodeJS加解密之Crypto</a></li><li>🌛 <a href="https://github.com/google/zx">zx - 谷歌开发的命令行脚本工具</a></li><li>🌛 <a href="https://github.com/node-fetch/node-fetch">node-fetch - node 环境下进行网络请求</a></li><li>⭐️ <a href="https://juejin.cn/post/6971770846872338439">浅析 NodeJS 多进程和集群</a></li><li>⭐️ <a href="https://github.com/privatenumber/tasuku">Tasuku - 面向 Node 的最小任务运行器</a></li><li>🌛 <a href="https://juejin.cn/post/7008504029277847565">Node.js的底层原理</a></li><li>⭐️ <a href="https://mp.weixin.qq.com/s/Gcx6E4cYo6WPB8PLI72NWg">认真写了个快速创建 Node 服务的CLI，看看对小伙伴们有帮忙吗？</a><ul><li>项目地址：<a href="https://github.com/koala-coding/create-bff-service-cli">https://github.com/koala-coding/create-bff-service-cli</a></li></ul></li></ul><h2>前端编译</h2><ul><li><a href="https://juejin.cn/post/7041021350114230285">V8 编译浅谈</a></li><li>⭐️ <a href="https://juejin.cn/post/7057354419888717855">编译技术在前端的实践（二）—— Antlr 及其应用</a></li><li>⭐️ <a href="https://juejin.cn/post/6989509925844041742">编译技术在前端的实践（一）—— 编译原理基础</a></li><li><a href="https://juejin.cn/post/6953963506693570573">前端也要懂编译：AST 从入门到上手指南</a></li></ul><h2>文件上传</h2><ul><li>⭐️ <a href="https://juejin.cn/post/6844904046436843527">字节跳动面试官：请你实现一个大文件上传和断点续传</a></li><li>⭐️ <a href="https://juejin.cn/post/6990283221170651149">从零开始手写一个「开箱即用的大文件分片上传库」</a></li><li><a href="https://juejin.cn/post/6992007156320960542">5000字带你全面深入理解JS中的Stream API｜8月更文挑战</a></li></ul><h2>网络相关</h2><ul><li>推荐看看 QUIC 101 视频以及 <a href="https://courses.cs.washington.edu/courses/cse550/20au/papers/CSE550.quic.pdf">The QUIC transport protocol: design and Internet-scale deployment</a> 论文</li><li>⭐️ <a href="https://segmentfault.com/a/1190000024523772">一文彻底搞懂加密、数字签名和数字证书！</a></li><li>⭐️ <a href="https://juejin.cn/post/6944420222757503006">一个Response Header引发的血案(包含CDN的相关概念)</a></li></ul><h2>操作系统</h2><ul><li><a href="https://juejin.cn/post/6917096816118857736">6w字搞定Linux基本操作，建议收藏</a></li><li><a href="https://juejin.cn/post/6844904080972709901">半小时搞会 CentOS 入门必备基础知识</a></li><li><a href="https://juejin.cn/post/6875323565479034894">手摸手带你 Docker 从入门到实践</a></li></ul><h2>机器学习</h2><ul><li><a href="https://www.bilibili.com/video/BV1cD4y1D7uR">《深入理解计算机系统》- bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1mb4y1d7K7">《计算机网络自顶向下方法》- bilibili</a><ul><li>这本书重点章节是第2、3、4、5、6章，其他章节可以跳过</li></ul></li><li>学习资源<ul><li><a href="https://github.com/ossu/computer-science">https://github.com/ossu/computer-science</a></li><li><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></li><li><a href="https://github.com/QSCTech/zju-icicles">https://github.com/QSCTech/zju-icicles</a></li></ul></li><li><a href="https://www.bilibili.com/video/BV1Vt411z7wy">一天学会 MySQL 数据库</a></li><li><a href="https://www.bilibili.com/video/BV1FT4y1E74V">吴恩达《深度学习》</a></li><li><a href="https://www.bilibili.com/video/BV1qK4y1479r">推荐系统算法基础+综合项目实战</a><ul><li>再就是一些我认为很优秀的开源项目：</li><li><a href="https://github.com/zhongqiangwu960812/AI-RecommenderSystem">https://github.com/zhongqiangwu960812/AI-RecommenderSystem</a></li><li><a href="https://github.com/ZiyaoGeng/Recommender-System-with-TF2.0">https://github.com/ZiyaoGeng/Recommender-System-with-TF2.0</a></li></ul></li><li>参考：<a href="https://mp.weixin.qq.com/s/YbwQAPIEkihO7XzVvrlDCg">万字入门推荐系统！</a></li><li><a href="https://juejin.cn/post/7013674501116264484">说一说Web端侧AI</a></li><li><a href="https://juejin.cn/post/6964335363787620383">机器学习初探-线性回归</a></li><li><a href="https://juejin.cn/post/6951340421658181646">机器学习进阶 - 深入思考逻辑回归</a></li></ul><h2>Java 相关</h2><ul><li><a href="https://blog.csdn.net/mu_wind/article/details/118423362">ElasticSearch进阶：一文全览各种ES查询在Java中的实现</a></li><li><a href="https://juejin.cn/post/7031047868806873096">使用 @Transactional 时常犯的N种错误</a></li><li><a href="https://juejin.cn/post/6984974277573836830">Spring Boot 2.x基础教程：使用@Scheduled实现定时任务</a></li><li><a href="https://juejin.cn/post/7007642025264676871">Spring Boot中使用@Async实现异步调用，加速任务的执行！</a></li><li><a href="https://github.com/fuzhengwei/CodeGuide">CodeGuide | 程序员编码指南</a></li><li><a href="https://github.com/fuzhengwei/small-spring">🌱 Spring 手撸专栏 - 易学、好写、能懂！</a></li></ul><h2>Golang 学习</h2><ul><li>⭐️ <a href="https://www.youtube.com/watch?v=YS4e4q9oBaU">Learn Go Programming - Golang Tutorial for Beginners</a></li><li><a href="https://juejin.cn/post/7061980386640789540">Go 学习路线（2022）</a></li><li><a href="https://github.com/wumansgy/GoAndBlockChainStudy">https://github.com/wumansgy/GoAndBlockChainStudy</a></li><li>⭐️ <a href="https://mp.weixin.qq.com/s/Xzlt_WcdcfLWhofafY3c6g">Golang 简洁架构实战</a></li><li>⭐️ <a href="https://juejin.cn/post/7065197280223035422">如何使用高阶函数编程提升代码的简洁性</a></li><li>🌛 <a href="https://mp.weixin.qq.com/s/36CqC1U54LUd4-izt4iZ1g">深入理解Go Json.Unmarshal精度丢失之谜</a></li><li><a href="https://segmentfault.com/a/1190000013739000">Golang 新手可能会踩的 50 个坑</a></li><li><a href="https://zhuanlan.zhihu.com/p/437626980">Golang设计模式总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/377834750">手把手教你如何进行 Golang 单元测试</a></li><li><a href="https://zhuanlan.zhihu.com/p/267341653">Golang 单元测试指引</a></li><li>⭐️ <a href="https://juejin.cn/post/7041846339189080101">使用Golang、Gin和React、esbuild开发的Blog</a></li><li>⭐️ <a href="https://github.com/go-gorm/gorm">gorm - Golang 的出色 ORM 库</a></li><li>⭐️ <a href="https://github.com/gofiber/fiber">fiber：受到 Express 启发的 Web 应用框架</a></li><li><a href="https://go.dev/">Golang 官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/426368274">Golang 编程思维和工程实战</a></li><li>⭐️ <a href="https://gobyexample.com/">Go by example</a></li></ul><h2>网站推荐</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/">MDN 文档</a></li><li><a href="https://caniuse.com/">caniuse：查询 API 兼容性</a></li><li><a href="https://es6.ruanyifeng.com/">阮一峰 ES6 教程</a></li><li><a href="https://unbug.github.io/codelf/">codelf 变量命名神器</a></li><li><a href="https://www.astexplorer.net/">AST explorer：可视化 AST</a></li><li><a href="https://openbase.com/">openbase：查询各种第三方库</a></li></ul><h2>学习资源</h2><ul><li>《Linux Shell 脚本攻略（第2版）》</li><li>《推荐系统——技术、评估及高效算法》</li><li>《Go 语言编程》</li><li>《Go 语言高级编程》</li><li>《操作系统导论》</li><li>《深入理解计算机系统》</li><li>《MySQL技术内幕》</li><li>《Redis设计与实现》</li><li>⭐️ <a href="https://www.bilibili.com/video/BV1EW411u7th">【计算机科学速成课】<!-- -->[<!-- -->40集全/精校<!-- -->]<!-- --> - Crash Course Computer Science</a></li><li>⭐️ <a href="https://www.bilibili.com/video/BV1iW411d7hd">【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频</a></li></ul><h2>面试相关</h2><ul><li><a href="https://github.com/ConardLi/awesome-coding-js">JS 数据结构与算法 - awesome-coding-js</a></li><li><a href="https://github.com/trekhleb/javascript-algorithms">JavaScript Algorithms and Data Structures</a></li><li><a href="https://juejin.cn/post/7023208826472005668">JavaScript算法基础及面试总结（1w1字）</a></li><li>⭐️ <a href="https://juejin.cn/post/6844903929705136141">如何写出一个惊艳面试官的深拷贝?</a></li><li>⭐️ <a href="https://juejin.cn/post/6844904118704668685">面了几个说自己精通 Vue 的同学</a></li><li><a href="https://blog.csdn.net/xgangzai/article/details/120375992">高频react面试题20道（附详解）</a></li><li><a href="https://juejin.cn/post/6844903885488783374">【1 月最新】前端 100 问：能搞懂 80% 的请把简历给我</a></li></ul><h2>前端测试</h2><ul><li><a href="https://juejin.cn/post/6943430853972852750">那些年错过的React组件单元测试（上）</a></li><li><a href="https://juejin.cn/post/6946008649026240519">那些年错过的React组件单元测试（下）</a></li><li><a href="https://juejin.cn/post/6999445868550029319">前端测试集锦——如何写好前端测试保证代码质量？</a></li></ul><h2>开发环境相关</h2><ul><li><a href="https://juejin.cn/post/7035448197883363359">【手把手】学会VS Code&quot;任务&quot;神技，成为项目组最靓的崽！</a></li><li><a href="https://juejin.cn/post/7019183422320934948">聊聊开发日常的效率提升工具（全）</a></li><li><a href="https://juejin.cn/post/6844904193828880391">打造舒适搬砖环境，这些是我最想推介的桌面好物</a></li><li><a href="https://juejin.cn/post/6844904012920127495">干货满满！推介几款 Mac 下非常好用的软件（第一弹）</a></li><li><a href="https://juejin.cn/post/6844904031685443592">干货满满！推介几款 Mac 下非常好用的软件（第二弹）</a></li></ul><h2>📒 掘金大佬汇总</h2><ul><li>Vue 源码、响应式机制：<a href="https://juejin.cn/user/2330620350708823/posts">ssh</a> 、<a href="https://juejin.cn/user/2137106333044861/posts">黄轶</a></li><li>React 进阶系列：<a href="https://juejin.cn/user/2418581313687390/posts">我不是外星人</a></li><li>Webpack 相关：<a href="https://juejin.cn/user/1820446985555544/posts">Tecvan</a></li><li>设计模式：<a href="https://juejin.cn/user/3544481219495806/posts">DYBOY</a></li><li>手写源码、设计模式：<a href="https://juejin.cn/user/2295436011645655/posts">蒋鹏飞</a></li><li>Webpack5、设计模式：<a href="https://juejin.cn/user/4300945218607197">清汤饺子</a></li><li>前端架构设计：<a href="https://juejin.cn/user/703340610597064/posts">寒草</a></li><li>总结大师：<a href="https://juejin.cn/user/2330620350432110/posts">JowayYoung</a></li><li>源码分析：若川</li><li>工程化知识卡片：<a href="https://juejin.cn/user/1556564164489389/posts">shanyue</a></li><li>前端工程化、个人服务器运维指南：<a href="https://shanyue.tech/op/#%E9%A2%84%E8%A7%88">shanyue</a></li><li>React 技术揭秘：<a href="https://react.iamkasong.com/">kasong</a></li><li>CSS 各种特效：<a href="https://juejin.cn/user/2330620350437678/posts">chokcoco</a></li><li>Golang 相关：<a href="https://zhuanlan.zhihu.com/p/340814811">腾讯技术工程</a></li><li>前端装逼技巧108式：<a href="https://segmentfault.com/u/king_hcj">独钓寒江雪</a></li><li>前端九条 bug 分享：<a href="https://segmentfault.com/u/lulu_up">lulu_up</a></li><li>Vue3 源码共读：<a href="https://www.bilibili.com/video/BV1bS4y1T7ng">前端杨村长</a></li><li>前端工程化、学习 Golang：洛竹</li><li>Node.js 相关：五月君</li></ul><h2>📒 待学习内容</h2><ul><li><a href="https://juejin.cn/post/7017360824939315207">babel源码详解-v1.7.8</a></li><li><a href="https://juejin.cn/post/6844904094079926286">最简实现Promise，支持异步链式调用（20行）</a></li><li><a href="https://juejin.cn/post/6844904116913700877">手写一个Promise/A+,完美通过官方872个测试用例</a></li><li><a href="https://juejin.cn/post/6889247428797530126">我在工作中写React，学到了什么？性能优化篇</a></li><li><a href="https://juejin.cn/post/6844903783005175815">如何利用lerna管理模块</a></li><li><a href="https://juejin.cn/post/6969544464113074189">基于 lerna 的多包 JavaScript 项目搭建维护</a></li><li><a href="https://juejin.cn/post/6844903896767283207#heading-5">React性能优化小贴士</a></li><li><a href="https://juejin.cn/post/6844903929726107655">神奇的lambda表达式——函数式编程必学</a></li><li><a href="https://juejin.cn/post/6844903954002739213">npm进阶——如何拥有自己的包和流程自动化</a></li><li><a href="https://juejin.cn/post/6844904162124103693">React Hooks的花样玩法</a><ul><li>useDark，useClickOutside，全局状态管理</li></ul></li><li><a href="https://juejin.cn/post/6844903845227659271">正则表达式不要背</a></li><li><a href="https://juejin.cn/post/6844903825145511950">我们或许不需要 classnames 这个库</a></li><li><a href="https://juejin.cn/post/7014431215302213668">国庆爆肝，用vite+vue3+ts实现一个网页版的typora！</a></li><li><a href="https://juejin.cn/post/6982192362583752741">手摸手教你使用最新版husky(v7.0.1)让代码更优雅规范</a></li><li><a href="https://juejin.cn/post/7015476516196712462">快速入手Electron，拥有一个自己的桌面应用</a></li><li><a href="https://juejin.cn/post/6945236994247098381">在大厂是如何高效组织 npm script 的</a></li><li><a href="https://juejin.cn/post/6940042028243746823">前端开发者周刊第三期：各大厂 webpack5 实践</a></li><li><a href="https://juejin.cn/post/6937176680251424775#heading-7">【译】下一代前端构建工具 ViteJS 中英双语字幕 ｜ 技术点评</a></li><li>⭐️ <a href="https://juejin.cn/post/6924258563862822919">Webpack5 新特性业务落地实战</a></li><li>⭐️ <a href="https://webpack.docschina.org/guides/development/#choosing-a-development-tool">Webpack 官方开发指南</a></li><li><a href="https://mp.weixin.qq.com/s/P3foOrcu4StJDGdX9xavng">构建效率大幅提升，webpack5 在企鹅辅导的升级实践</a></li><li><a href="https://mp.weixin.qq.com/s/ZP2IigNVSIZKGuYxNYOYgw">如何利用 monorepo 策略管理代码？</a></li><li><a href="https://juejin.cn/post/6924854598268108807">All in one：项目级 monorepo 策略最佳实践</a></li><li><a href="https://juejin.cn/post/7007252464726458399">一顿操作，我把 Table 组件性能提升了十倍</a></li></ul><h2>📒 小目标</h2><ul><li>Vue 3.x 源码；</li><li>Vuex 4.x 源码；</li><li>Vue-Router 源码；</li><li>搭建脚手架工具（Webpack5 新特性实践）；</li><li>VS Code extension ；</li><li>cocos 游戏开发；</li><li>手写 redux 源码；</li><li>手写 redux-thunk 源码；</li><li>手写 Promise/A+ ；<ul><li><a href="https://juejin.cn/post/6844904116913700877">手写一个Promise/A+,完美通过官方872个测试用例</a></li><li><a href="https://juejin.cn/post/6945319439772434469">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a></li><li><a href="https://juejin.cn/post/7055202073511460895">V8 Promise源码全面解读，其实你对Promise一无所知</a></li><li><a href="https://juejin.cn/post/6844904094079926286">最简实现Promise，支持异步链式调用（20行）</a></li><li><a href="https://juejin.cn/post/7043758954496655397">手把手一行一行代码教你“手写Promise“，完美通过 Promises/A+ 官方872个测试用例</a></li></ul></li><li>排序算法，桶排序、计数排序，时间复杂度 O(n) ；</li><li>每日算法<ul><li><a href="https://labuladong.gitee.io/algo/">https://labuladong.gitee.io/algo/</a>（国内速度快，体验好，推荐）</li><li><a href="https://labuladong.github.io/algo/">https://labuladong.github.io/algo/</a></li><li><a href="https://mp.weixin.qq.com/s/AzQzw-pC8A-0kS0NJn2eWw">手把手刷二叉树系列完结篇</a></li><li><a href="https://mp.weixin.qq.com/s/hGrTUmM1zusPZZ0nA9aaNw">前缀树算法模板秒杀 5 道算法题</a></li><li><a href="https://mp.weixin.qq.com/s/5GO2ZITncVArdm4KITBd9g">集合划分问题：排列组合中的回溯思想（修订版）</a></li><li><a href="https://mp.weixin.qq.com/s/ir1Hk06HcT8W_qz0MtyONA">2021 公众号精选文章目录</a></li></ul></li><li>看下面的文章，手写一个 <code>babel-plugin-import</code><ul><li><a href="https://juejin.cn/post/6930877602840182791">手写一个webpack，看看AST怎么用｜牛气冲天新年征文</a></li><li><a href="https://juejin.cn/post/6987036612035084296">今天，我们来实现一个基础版的webpack</a></li><li><a href="https://juejin.cn/post/6953963506693570573">前端也要懂编译：AST 从入门到上手指南</a></li><li><a href="https://juejin.cn/post/7026658230365323301">跟着源码了解Webpack编译流程</a></li><li><a href="https://juejin.cn/post/6859538537830858759">面试官：webpack原理都不会？</a></li><li><a href="https://juejin.cn/post/7026671646555504676">让 AST 操作像呼吸一样自然</a></li></ul></li><li>手把手实现一个 babel 插件<ul><li>这篇做的 demo 是一个简单的 babel-plugin-import</li><li><a href="https://juejin.cn/post/6844903746804137991">深入Babel，这一篇就够了</a></li><li>这篇做的 demo 类似 Java 中的 lambok</li><li><a href="https://juejin.cn/post/7012424646247055390">保姆级教学！这次一定学会babel插件开发！</a></li><li><a href="https://juejin.cn/post/7061808830274863118">操作 JavaScript 的 AST</a></li></ul></li><li>diff 算法相关<ul><li><a href="https://github.com/snabbdom/snabbdom">https://github.com/snabbdom/snabbdom</a></li><li><a href="https://github.com/snabbdom/snabbdom/blob/master/src/init.ts">https://github.com/snabbdom/snabbdom/blob/master/src/init.ts</a></li><li>⭐️ <a href="https://mp.weixin.qq.com/s/8M-pJdKjF6bx5ijtSFKIcw">图解Diff算法——Vue篇</a></li><li>⭐️ <a href="https://juejin.cn/post/7067693810918096903">浅析 Snabbdom 中 vnode 和 diff 算法</a></li><li><a href="https://juejin.cn/post/6997965021401579556">diff 算法深入一下？</a></li><li><a href="https://juejin.cn/post/7000266544181674014">DIff算法看不懂就一起来砍我(带图)</a></li><li><a href="https://juejin.cn/post/6966215704634720287">关于Virtual DOM理解和Snabbdom源码浅析</a></li><li><a href="https://github.com/shfshanyue/mini-code/blob/master/code/vdom/index.js">shanyue mini-code vdom</a></li><li><a href="https://juejin.cn/post/6976232466059100197">Virtual DOM到底有什么迷人之处？如何搭建一款迷你版Virtual DOM库？</a></li><li><a href="https://juejin.cn/post/6919376064833667080">React、Vue2、Vue3的三种Diff算法</a></li><li><a href="https://www.zhihu.com/question/31809713/answer/53544875">网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？- 知乎</a></li></ul></li><li>webpack 热模块替换看下源码<ul><li><a href="https://juejin.cn/post/7049608872553611301">webpack模块热更新原理</a></li><li><a href="https://juejin.cn/post/7021729340945596424">Webpack 原理系列十：HMR 原理全解析</a></li><li><a href="https://juejin.cn/post/7031546400034947108">Webapck5核心打包原理全流程解析</a></li></ul></li><li>Docker 相关总结一下</li><li>前端框架源码<ul><li>⭐️ <a href="https://juejin.cn/book/6945998773818490884">React 进阶实践指南</a></li><li>⭐️ <a href="https://juejin.cn/post/7069555976717729805">「React进阶」react-router v6 通关指南</a></li><li><a href="https://juejin.cn/post/6982004709145968677">[<!-- -->建议收藏<!-- -->]<!-- --> 你想知道的Vue3核心源码这里都有</a></li><li><a href="https://juejin.cn/post/6978654109893132318">手写系列-实现一个铂金段位的 React</a></li><li><a href="https://juejin.cn/post/6844904197008130062">手写React的Fiber架构，深入理解其原理</a></li><li><a href="https://juejin.cn/post/6859528127010471949">React Fiber 源码解析</a></li><li><a href="https://juejin.cn/post/6943896410987659277">走进React Fiber的世界</a></li><li><a href="https://juejin.cn/post/6911681589558640654">前端工程师的自我修养：React Fiber 是如何实现更新过程可控的</a></li><li><a href="https://juejin.cn/post/6984949525928476703">React Fiber很难？六个问题助你理解 React Fiber</a></li></ul></li><li>工程化方案总结下<ul><li><a href="https://zhuanlan.zhihu.com/p/403970666">2021 年 TypeScript + React 工程化指南</a></li><li><a href="https://juejin.cn/post/7017710911443959839">2021 年当我们聊前端部署时，我们在聊什么</a></li><li><a href="https://juejin.cn/post/7023242274876162084">🔥【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系</a></li><li><a href="https://github.com/vercel/next.js/blob/canary/packages/next/build/webpack-config.ts">Next.js webpack 配置</a></li></ul></li><li><a href="https://juejin.cn/post/6992172458748936222">面向未来的前端开发模式 - 写于2021年</a></li><li><a href="https://juejin.cn/post/6990538424545443854">从零搭建Webpack5-react脚手架(附源码)</a></li><li><a href="https://github.com/JinJieTan/Peter-">手写各种源码</a></li></ul><h2>📒 推荐阅读</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/403970666">2021 年 TypeScript + React 工程化指南</a></li><li><a href="https://juejin.cn/post/6996816316875161637#heading-15">学习 Webpack5 之路（优化篇）- 近 7k 字</a></li><li><a href="https://github.com/webpack/webpack-dev-middleware">https://github.com/webpack/webpack-dev-middleware</a></li><li><a href="https://segmentfault.com/a/1190000011761306">webpack-dev-middleware 插件的使用</a></li><li><a href="https://juejin.cn/post/6844904099985489927">webpack-dev-middleware 源码解读</a></li><li><a href="https://juejin.cn/post/6949040393165996040#heading-2">[<!-- -->万字总结<!-- -->]<!-- --> 一文吃透 Webpack 核心原理</a></li><li><a href="https://juejin.cn/post/7020678344219820068">跟村长老师做【Vue DevUI 开源指南】直播一个月的感受</a></li><li><a href="https://juejin.cn/post/7021167384484380709">工程化知识卡片 008: webpack HMR 实现的核心原理</a></li><li><a href="https://juejin.cn/post/7030207667457130527">基于 Lerna 实现 Monorepo 项目管理</a></li><li><a href="https://juejin.cn/post/6959115798841393160">手摸手教你用Vue3+Typescript+Rollup+Tailwinds打造插拔式的业务组件库</a></li><li><a href="https://juejin.cn/post/6869551115420041229">一文带你快速上手Rollup</a></li><li>🌛 <a href="https://juejin.cn/post/7029525775321661470">手摸手学会搭建一个 TS+Rollup 的初始开发环境</a></li><li><a href="https://juejin.cn/post/7029292539479867429">【我要做开源】Vue DevUI开源指南08：如何实现组件的按需打包📦</a></li><li><a href="https://juejin.cn/post/7029262501833359368">【我要做开源】Vue DevUI开源指南08：Monorepo改造</a></li><li><a href="https://juejin.cn/post/6974377246140301342">coding优雅指南：函数式编程</a></li><li><a href="https://juejin.cn/post/6892886272377880583">这些高阶的函数技术，你掌握了么</a></li><li>🌛 <a href="https://juejin.cn/post/7028222480326066213">使用Docker Compose、Nginx、SSH和Github Actions实现前端自动化部署测试机</a></li><li><a href="https://juejin.cn/post/6844904093434019853">如何推动前端团队的基础设施建设</a></li><li>⭐️ <a href="https://juejin.cn/post/6966491047257964575">Element UI源码中学到的技巧</a></li><li><a href="https://juejin.cn/post/7026658230365323301">跟着源码了解Webpack编译流程</a></li><li><a href="https://juejin.cn/post/6859538537830858759">面试官：webpack原理都不会？</a></li><li><a href="https://juejin.cn/post/7026671646555504676">让 AST 操作像呼吸一样自然</a></li><li><a href="https://juejin.cn/post/6920044884594425864">从零撸一个CLI命令行脚手架工具</a></li><li><a href="https://juejin.cn/post/6844904197863964685">从 Element UI 源码的构建流程来看前端 UI 库设计</a></li><li><a href="https://juejin.cn/post/6943430853972852750">那些年错过的React组件单元测试（上）</a></li><li><a href="https://juejin.cn/post/6946008649026240519">那些年错过的React组件单元测试（下）</a></li><li><a href="https://juejin.cn/post/7026274816734789663">git hooks 的库 husky 源码这么简单，你也可以实现一个！</a></li><li><a href="https://juejin.cn/post/7026210002042011655">「React18新特性」深度解读之useMutableSource</a></li><li><a href="https://juejin.cn/post/6953452438300917790">【V8源码补充篇】从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a></li><li><a href="https://juejin.cn/post/6966422095274180639">[<!-- -->探索<!-- -->]<!-- -->Webpack DevServer和HMR原理</a></li><li><a href="https://juejin.cn/post/7023242274876162084">【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系</a></li><li><a href="https://juejin.cn/post/6844903881390964744">从头开始，彻底理解服务端渲染原理(8千字汇总长文)</a></li><li><a href="https://juejin.cn/post/6982157120594509837">剖析 Webpack SplitChunksPlugin 源码: 学完你也能写一个</a></li><li><a href="https://juejin.cn/post/7025164660751990798">一点关于服务端渲染的分享</a></li><li><a href="https://juejin.cn/post/6966119324478079007">从 0 构建自己的脚手架/CLI知识体系（万字） 🛠</a></li><li><a href="https://juejin.cn/post/6984939221681176607">手写一个虚拟DOM库，彻底让你理解diff算法</a></li><li><a href="https://juejin.cn/post/6854573215969181703">10个简单的技巧让你的 vue.js 代码更优雅🍊</a></li><li><a href="https://juejin.cn/post/7026119446162997261">在 Vue 中为什么不推荐用 index 做 key</a></li><li><a href="https://www.zhihu.com/question/384048633/answer/1134746899">做了两年前端开发，平时就是拿 Vue 写写页面和组件，简历的项目经历应该怎么写得好看？</a></li><li><a href="https://juejin.cn/post/7017710911443959839">2021 年当我们聊前端部署时，我们在聊什么</a></li><li><a href="https://juejin.cn/post/7016534471734198279">分享一年以来的Electron开发经验</a></li><li><a href="https://juejin.cn/post/6844903938894872589">「前端进阶」高性能渲染十万条数据(时间分片)</a></li><li>⭐️ <a href="https://juejin.cn/post/6978654109893132318">手写系列-实现一个铂金段位的 React</a></li><li><a href="https://juejin.cn/post/6973155726302642206">手写系列-这一次，彻底搞懂 Promise</a></li><li><a href="https://juejin.cn/post/7005375860509245471">50行代码串行Promise，koa洋葱模型原来是这么实现？</a></li><li><a href="https://juejin.cn/post/6882290865763680264">玩转 node 子进程 — child_process</a></li><li><a href="https://juejin.cn/post/6844903895467032589">深入剖析：Vue核心之虚拟DOM</a></li><li>⭐️ <a href="https://juejin.cn/post/6844904055618158600">从零开始配置 react + typescript（一）：dotfiles</a></li><li><a href="https://juejin.cn/post/6937125495439900685">Webpack 案例 —— vue-loader 原理分析</a></li><li><a href="https://juejin.cn/post/7025213391618703367">TypeScript 实现斐波那契数列</a></li><li><a href="https://juejin.cn/post/6965320374451961886">用ts类型系统实现斐波那契数列</a></li><li><a href="https://juejin.cn/post/7059400669916037133">初步尝试 tauri，并且与 electron.js 对比</a></li><li><a href="https://juejin.cn/post/7057178581897740319">和大多数的前端开发者相比，我并没有选择node.js做cli而投靠了golang</a></li></ul>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[3月13日内容汇总]]></title>
        <id>3月13日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/3月13日内容汇总"/>
        <updated>2022-03-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 10 React Antipatterns to Avoid - Code This, Not That!]]></summary>
        <content type="html"><![CDATA[<p>📒 10 React Antipatterns to Avoid - Code This, Not That!</p><blockquote><p><a href="https://www.youtube.com/watch?v=b0IZo2Aho9Y">https://www.youtube.com/watch?v=b0IZo2Aho9Y</a></p></blockquote><p>📒 markdown 编辑器滚动如何实现联动</p><pre><code class="language-js">const ScrollTarget = {
  NONE: &quot;NONE&quot;,
  EDITOR: &quot;EDITOR&quot;,
  RENDER: &quot;RENDER&quot;,
};

let curTarget = ScrollTarget.NONE;
let timer = null;

const scrollManager = (handler) =&gt; (target) =&gt; {
  if ((curTarget = ScrollTarget.NONE)) {
    curTarget = target;
  }
  if (curTarget === target) {
    handler(target);
    if (timer) clearTimeout(timer);
    timer = setTimeout(() =&gt; {
      curTarget = ScrollTarget.NONE;
    }, 100);
  }
};

const scrollFn = scrollManager(handleScroll);
</code></pre><p>📒 Webpack 的模块规范</p><p>Webpack 基于 CJS 和 ESM 规范实现了模块机制，但也不是完全基于，而是在这些模块规范基础上扩展了一套自己的 api，用于增强功能，例如：</p><ul><li><code>require.context</code></li><li>使用 <code>import</code> 加载 <code>.json</code> 模块</li></ul><blockquote><p>在 ESM 规范中 <code>import</code> 只能用于加载 JS 模块，只有 <code>require</code> 可以加载 json 模块</p></blockquote><p>📒 如何将对象序列化为查询字符串</p><pre><code class="language-js">const aaa = {a: 1, b: 2, c: &quot;2333&quot;}
</code></pre><p>第一种手动拼接，简单直接，一行代码搞定：</p><pre><code class="language-js">const _stringify =
  (obj) =&gt; Object.entries(obj).map(([key, val]) =&gt; `${key}=${val}`).join(&quot;&amp;&quot;);
</code></pre><p>还可以使用 <code>URLSearchParams</code> 对象进行拼接：</p><pre><code class="language-js">const _stringify = obj =&gt; Object.entries(obj).reduce((accu, [key, val]) =&gt; {
  accu.append(key, val);
  return accu;
}, new URLSearchParams)
</code></pre><p>📒 「深入浅出」主流前端框架更新批处理方式</p><p>浏览器环境下，宏任务的执行并不会影响到浏览器的渲染和响应，即宏任务优先级低于页面渲染。</p><pre><code class="language-js">function run(){
  setTimeout(() =&gt; {
    console.log(&#x27;----宏任务执行----&#x27;)
    run()
  }, 0)
}
// 通过递归调用 run 函数，让 setTimeout 宏任务反复执行
// 这种情况下 setTimeout 执行并不影响页面渲染和交互事件
run()
</code></pre><p>微任务会在当前 event loop 中执行完毕，会阻塞浏览器的渲染和响应，即微任务优先级高于页面渲染。</p><pre><code class="language-js">function run(){
  Promise.resolve().then(() =&gt; {
    run()
  })
}
// 在这种情况下，页面直接卡死了，没有响应
run()
</code></pre><p>这里主要就是理解关键渲染路径，即浏览器渲染一帧会先执行脚本，再页面布局，绘制渲染。如果是宏任务，浏览器会把每一次事件回调放在下一帧渲染前执行，这样可以确保浏览器每一帧都能正常渲染。如果是微任务，浏览器在执行渲染之前会清空微任务队列，会导致一直停留在当前 event loop，相当于脚本一直在执行，如果长时间不把控制权交还给浏览器，就会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。</p><p><a href="https://juejin.cn/post/7072156913789566989">「深入浅出」主流前端框架更新批处理方式</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[3月6日内容汇总]]></title>
        <id>3月6日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/3月6日内容汇总"/>
        <updated>2022-03-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 通过Vue自定义指令实现前端埋点]]></summary>
        <content type="html"><![CDATA[<p>📒 <a href="https://mp.weixin.qq.com/s/baVNEeZZdmqUiolyssZgqg">通过Vue自定义指令实现前端埋点</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/qnA1tFKMXr7hwsEKFXKOZg">Deno 简介：它比 Node.js 更好吗？</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/2leA0q8QQvdQzv86ic7ZEg">快来玩转这 19 个 css 技巧</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/l3l9d9sLiWoUM381E9o-3Q">解决了 Redis 大 key 问题，同事们都说牛皮！</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/l_YdpyHht5Ayvrc7LFZNIA">图解|Linux内存背后的那些神秘往事</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/36CqC1U54LUd4-izt4iZ1g">深入理解Go Json.Unmarshal精度丢失之谜</a></p><p>📒 如何理解快速排序和归并排序</p><p>快速排序实际就是二叉树的前序遍历，归并排序实际就是二叉树的后序遍历。</p><p>快速排序的逻辑是，若要对 <code>nums[lo..hi]</code> 进行排序，我们先找一个分界点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p]</code>，然后递归地去 <code>nums[lo..p-1]</code> 和 <code>nums[p+1..hi]</code> 中寻找新的分界点，最后整个数组就被排序了。</p><p>快速排序的代码框架如下：</p><pre><code class="language-java">void sort(int[] nums, int lo, int hi) {
  /****** 前序遍历位置 ******/
  // 通过交换元素构建分界点 p
  int p = partition(nums, lo, hi);
  /************************/

  sort(nums, lo, p - 1);
  sort(nums, p + 1, hi);
}
</code></pre><blockquote><p>先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗</p></blockquote><p>再说说归并排序的逻辑，若要对 <code>nums[lo..hi]</code> 进行排序，我们先对 <code>nums[lo..mid]</code> 排序，再对 <code>nums[mid+1..hi]</code> 排序，最后把这两个有序的子数组合并，整个数组就排好序了。</p><p>归并排序的代码框架如下：</p><pre><code class="language-java">void sort(int[] nums, int lo, int hi) {
  int mid = (lo + hi) / 2;
  // 排序 nums[lo..mid]
  sort(nums, lo, mid);
  // 排序 nums[mid+1..hi]
  sort(nums, mid + 1, hi);

  /****** 后序位置 ******/
  // 合并 nums[lo..mid] 和 nums[mid+1..hi]
  merge(nums, lo, mid, hi);
  /*********************/
}
</code></pre><blockquote><p>先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀</p></blockquote><p>说了这么多，旨在说明，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题。</p><p>📒 Leetcode 236 二叉树最近公共祖先</p><p><code>lowestCommonAncestor</code> 方法的定义：给该函数输入三个参数 <code>root</code>，<code>p</code>，<code>q</code>，它会返回一个节点。</p><ul><li>情况 1，如果 <code>p</code> 和 <code>q</code> 都在以 <code>root</code> 为根的树中，函数返回的即 <code>p</code> 和 <code>q</code> 的最近公共祖先节点。</li><li>情况 2，如果 <code>p</code> 和 <code>q</code> 都不在以 <code>root</code> 为根的树中，则理所当然地返回 <code>null</code> 呗。</li><li>情况 3，如果 <code>p</code> 和 <code>q</code> 只有一个存在于 <code>root</code> 为根的树中，函数就返回那个节点。</li></ul><p>:::tip</p><p>题目说了输入的 <code>p</code> 和 <code>q</code> 一定存在于以 <code>root</code> 为根的树中，但是递归过程中，以上三种情况都有可能发生，所以说这里要定义清楚，后续这些定义都会在代码中体现。</p><p>函数参数中的变量是 <code>root</code>，因为根据框架，<code>lowestCommonAncestor(root)</code> 会递归调用 <code>root.left</code> 和 <code>root.right</code>；至于 <code>p</code> 和 <code>q</code>，我们要求它俩的公共祖先，它俩肯定不会变化的。你也可以理解这是「状态转移」，每次递归在做什么？不就是在把「以root为根」转移成「以root的子节点为根」，不断缩小问题规模嘛</p><p>:::</p><pre><code class="language-java">class Solution {
  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // 两个 base case
    // 1.如果 root 为空，直接返回 null
    if (root == null) return null;
    // 2.如果 root 本身就是 p 或者 q
    // 例如 root 是 p 节点，如果 q 存在于以 root 为根的树中，显然 root 就是最近公共祖先
    // 即使 q 不存在于以 root 为根的树中，按照情况 3 的定义，也应该返回 root 节点
    if (root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);

    // 在后序位置分情况讨论
    // 情况 1，如果 p 和 q 都在以 root 为根的树中
    // 那么 left 和 right 一定分别是 p 和 q（从 base case 看出）
    // 由于后序位置是从下往上，就好比从 p 和 q 出发往上走
    // 第一次相交的节点就是这个 root，显然就是最近公共祖先
    if (left != null &amp;&amp; right != null) {
      return root;
    }
    // 情况 2，如果 p 和 q 都不在以 root 为根的树中，直接返回 null
    if (left == null &amp;&amp; right == null) {
      return null;
    }
    // 情况 3，如果 p 和 q 只有一个存在于 root 为根的树中，函数返回该节点
    return left == null ? right : left;
  }
}
</code></pre><blockquote><p>在前序位置搜索节点，如果是空节点直接返回，如果搜索到 <code>p</code> 或者 <code>q</code> 返回该节点，否则继续递归</p></blockquote><blockquote><p>在后序位置接收前序的返回值，如果 <code>left</code> 和 <code>right</code> 都不为空，说明分别是 <code>p</code> 和 <code>q</code>，当前 <code>root</code> 就是最近公共祖先，直接返回 <code>root</code> 节点。如果一个为空另一个不为空，说明找到一个节点，把这个节点向上传递，查找另一个节点，直到出现两个都不为空，此时 <code>root</code> 就是最近公共祖先，直接返回 <code>root</code> 节点</p></blockquote><p>📒 如何写对二分查找</p><ul><li>不要使用 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚</li><li>计算 <code>mid</code> 时需要防止溢出，使用 <code>left + (right - left) / 2</code> 先减后加这样的写法</li><li><code>while</code> 循环的条件 <code>&lt;=</code> 对应 <code>right</code> 初始值为 <code>nums.length - 1</code>，此时终止条件是 <code>left == right + 1</code>，例如 <code>[3, 2]</code></li><li>如果 <code>while</code> 循环的条件 <code>&lt;</code>，需要把 <code>right</code> 初始值改为 <code>nums.length</code>，此时终止条件是 <code>left == right</code>，例如 <code>[2, 2]</code>，这样会漏掉最后一个区间的元素，需要单独判断下</li><li>当 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code>，对应 <code>left = mid + 1</code> 或者 <code>right = mid - 1</code></li><li>二分查找时间复杂度 <code>O(logn)</code></li></ul><pre><code class="language-java" metastring="{4,6,11,13}">class Solution {
  public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1; // 注意

    while (left &lt;= right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] == target) {
        return mid;
      } else if (nums[mid] &lt; target) {
        left = mid + 1; // 注意
      } else if (nums[mid] &gt; target) {
        right = mid - 1; // 注意
      }
    }
    return -1;
  }
}
</code></pre><p>📒 前端三种 Content-Type</p><p><code>application/json</code>：这种应该是接口请求用到最多的，可以使用 <code>JSON.stringify()</code> 序列化得到，实际传递的内容类似于：</p><pre><code class="language-json">{&quot;a&quot;: &quot;111&quot;, &quot;b&quot;: &quot;222&quot;}
</code></pre><p><code>application/x-www-form-urlencoded</code>：这是表单提交对应的 Content-Type，实际上就是通过 body 传递 query 参数，如使用 HTML 的表单元素，浏览器会自动进行拼接，也可通过 <code>URLSearchParams</code> 拼接得到，实际传递的内容类似于：</p><pre><code class="language-json">a=111&amp;b=222
</code></pre><p><code>multipart/form-data</code>：是通过 <code>FormData</code> 对象构造出来的表单格式，通常用于文件上传，实际传递的报文内容类似于：</p><pre><code class="language-http">POST /test.html HTTP/1.1
Host: example.org
Content-Type: multipart/form-data;boundary=&quot;boundary&quot;

--boundary
Content-Disposition: form-data; name=&quot;field1&quot;

value1
--boundary
Content-Disposition: form-data; name=&quot;field2&quot;; filename=&quot;example.txt&quot;

value2
--boundary--
</code></pre><blockquote><p>顺便提一下，文件下载对应的 Content-Type 是 <code>application/octet-stream</code></p></blockquote><p>📒 如何理解 Node.js 模块</p><p>一个模块实际上可以看做一个 <code>once</code> 函数，头部的 <code>require</code> 命令可以看做入参，<code>module.exports</code> 可以看做返回值。</p><p>当首次加载一个模块的时候，就会运行这个模块代码，可以看做是调用一个函数，执行结束后得到导出的内容并被缓存，可以看做函数返回一个值。当再次加载这个模块，不再执行这个模块代码，而是直接从缓存中取值。</p><p>在一个函数中，我们知道可以使用 <code>return</code> 语句提前结束运行，那么在模块中如何实现呢，答案是使用 <code>process.exit(1)</code>：</p><pre><code class="language-js">const fs = require(&quot;node:fs&quot;);
const path = require(&quot;node:path&quot;);
const webpack = require(&quot;webpack&quot;);

const workDir = process.cwd();
const envFilePath = path.resolve(workDir, &quot;./.env.local&quot;);
const hasEnvFile = fs.existsSync(envFilePath);

if (!hasEnvFile) {
  process.exit(1);
}

module.exports = {
  mode: &quot;development&quot;,
  entry: &#x27;./src/index.js&#x27;,
  output: {
    path: path.resolve(__dirname, &#x27;./dist&#x27;),
    filename: &#x27;[chunkhash].bundle.js&#x27;,
    clean: true
  },
}
</code></pre><blockquote><p>这里注意下，<code>fs.exists()</code> 方法已经废弃了，但是 <code>fs.existsSync()</code> 仍然可用。此外还可使用 <code>fs.stat()</code> 或者 <code>fs.access()</code> 检查文件是否存在</p></blockquote><p>📒 <a href="https://juejin.cn/post/7070364142015610888">在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</a></p><p>📒 <a href="https://juejin.cn/post/7070683049049980941">一键部署 K8S 环境，10分钟玩转，这款开源神器实在太香了！</a></p><p>📒 charles 如何连接手机抓包</p><ul><li>确保手机和电脑连接的是同一个网络</li><li>首先打开 charles，会启动一个服务，查看端口：proxy -&gt; proxy setting</li><li>勾选 Enable transparent HTTP proxying</li><li>查看本机 IP</li><li>在手机上设置 http 代理服务器，输入 IP 和端口</li><li>此时 charles 会弹出提示，有新的连接，点击 allow</li></ul><p>📒 前端项目的 <code>.env</code> 文件是如何生效的，一句话总结</p><p>通过 <code>dotenv</code> 这个包解析 <code>.env</code> 文件，加载到 <code>process.ENV</code> 里面，这时候可以通过 <code>process.ENV.xxx</code> 访问到环境变量，适用于 Node.js 项目，但是由于浏览器环境访问不到 <code>process</code> 对象，所以对于前端项目，还需要使用 Webpack 的 DefinePlugin 在打包构建阶段将变量替换为对应的值。</p><p>📒 如何防止用户篡改 url 参数</p><blockquote><p>http://localhost:8080/codepc/live?codeTime=1646038261531&amp;liveId=5e24dd3cf03a&amp;sign=e8fe282676f584ceab7e35f84cbc52ff&amp;keyFrom=youdao</p></blockquote><p>前端的直播链接带有 <code>codeTime</code> 和 <code>liveId</code>，如何防止用户篡改。只需要后端在返回 <code>codeTime</code> 和 <code>liveId</code> 的时候，同时计算一个签名 <code>sign</code> 返回给前端，前端提交给后端的时候，同时传递三个参数，后端计算一个新的签名，与前端传过来的 <code>sign</code> 进行比对，如果一样就说明没有篡改。</p><p>但是计算签名用的 md5 是一个公开的算法，假如有人篡改了 <code>codeTime</code> 和 <code>liveId</code> ，只要他使用 md5 计算一个新的签名 <code>sign</code> ，这样传给后端校验必然可以通过。这就需要后端签名的时候拼接一个加密串进去，验签的时候也用这个加密串。这样由于别人不知道加密串，即便生成新的签名，后端校验也不会通过。</p><p>📒 <a href="https://juejin.cn/post/7070481262749679653">了解下Rust 模块使用方式</a></p><p>🌛 <a href="https://mp.weixin.qq.com/s/nrTpZ9b9RvfNsaEkJoHMvg">一文秒杀排列组合问题的 9 种题型</a></p><p>📒 Screenshot: 不依赖浏览器原生能力的截屏库</p><p>该库基于 MediaDevice API 来提供了易于截屏的抽象。如果你有兴趣可以来看看 GitHub 仓库</p><blockquote><p><a href="https://github.com/xataio/screenshot">https://github.com/xataio/screenshot</a></p></blockquote><p>📒 enum-xyz：使用 Proxy 实现 JavaScript 中的枚举</p><p>一个 js-weekly 的读者，分享的有趣实现思路。源码很短，推荐看一下</p><blockquote><p><a href="https://github.com/chasefleming/enum-xyz">https://github.com/chasefleming/enum-xyz</a></p></blockquote><p>📒 <a href="https://mp.weixin.qq.com/s/E82Kz14tnG4hRSmwZQmacQ">使用 React 和 Tailwind 创建阅读进度条</a></p><p>📒 <a href="https://juejin.cn/post/7070395594379886629">React内部让人迷惑的性能优化策略</a></p><p>📒 <a href="https://juejin.cn/post/7070377945553977357">Nest.js 基于 Express 但也不是完全基于</a></p><p>📒 如何使用代理模式优化代码</p><p>开发环境下打印日志：</p><pre><code class="language-js">const dev = process.env.NODE_ENV === &#x27;development&#x27;;
const createDevFn = (cb) =&gt; {
    return (...args) =&gt; dev &amp;&amp; cb(...args);
};

const log = createDevFn(console.log);
log(&quot;23333&quot;); // &quot;2333&quot;
</code></pre><p>异常捕获：</p><pre><code class="language-js">class ExceptionsZone {
  static handle(exception) {
    console.log(&#x27;Error：&#x27;,exception.message, exception.stack);
  }

  static run(callback) {
    try {
      callback();
    } catch (e) {
      this.handle(e);
    }
  }
}

function createExceptionZone(target) {
  return (...args) =&gt; {
    let result;
    ExceptionsZone.run(() =&gt; {
      result = target(...args);
    });
    return result;
  };
}

const request = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 2000));
const requestWithHandler = createExceptionZone(request);
requestWithHandler().then(res =&gt; console.log(&quot;请求结果：&quot;, res));
</code></pre><p><a href="https://juejin.cn/post/7070120806214271012">如何用 Proxy 更优雅地处理异常</a></p><p>📒 <a href="https://juejin.cn/post/7070109475419455519">VuePress 博客优化之开启 Algolia 全文搜索</a></p><p>📒 Git 分支操作流程</p><p>在 Git Flow 中，有两个长期存在且不会被删除的分支：<code>master</code> 和 <code>develop</code></p><ul><li><code>master</code> 主要用于对外发布稳定的新版本，该分支时常保持着软件可以正常运行的状态，不允许开发者直接对 master 分支的代码进行修改和提交。当需要发布新版本时，将会与 <code>master</code> 分支进行合并，发布时将会附加版本编号的 Git 标签</li><li><code>develop</code> 则用来存放我们最新开发的代码，这个分支是我们开发过程中代码中心分支，这个分支也不允许开发者直接进行修改和提交。程序员要以 <code>develop</code> 分支为起点新建 <code>feature</code> 分支，在 <code>feature</code> 分支中进行新功能的开发或者代码的修正</li></ul><blockquote><p>注意 <code>develop</code> 合并的时候，不要使用 <code>fast-farward merge</code>，建议加上 <code>--no-ff</code> 参数，这样在 <code>master</code> 上就会有合并记录</p></blockquote><p>除了这两个永久分支，还有三个临时分支：<code>feature branches</code>、<code>hotfixes</code> 以及 <code>release branches</code></p><ul><li><code>feature branches</code> 是特性分支，也叫功能分支。当你需要开发一个新的功能的时候，可以新建一个 <code>feature-xxx</code> 的分支，在里边开发新功能，开发完成后，将之并入 <code>develop</code> 分支中</li><li><code>hotfixes</code> 就是用来修复 BUG 的。当我们的项目上线后，发现有 BUG 需要修复，那么就从 <code>master</code> 上拉一个名为 <code>fixbug-xxx</code> 的分支，然后进行 BUG 修复，修复完成后，再将代码合并到 <code>master</code> 和 <code>develop</code> 两个分支中，然后删除 <code>hotfix</code> 分支</li><li><code>release branches</code> 是发版的时候拉的分支。当我们所有的功能做完之后，准备要将代码合并到 <code>master</code> 的时候，从 <code>develop</code> 上拉一个 <code>release-xxx</code> 分支出来，这个分支一般处理发版前的一些提交以及客户体验之后小 BUG 的修复（BUG 修复后也可以将之合并进 <code>develop</code>），不要在这个里边去开发功能，在预发布结束后，将该分支合并进 <code>develop</code> 以及 <code>master</code>，然后删除 <code>release</code></li></ul><p><img src="./git-flow.png" alt="image"/></p><p>📒 <a href="https://mp.weixin.qq.com/s/-u7tnhD8YoOV9bkC62S6Pg">大厂动态规划面试汇总，重量级干货，彻夜整理</a></p><p>⭐️ <a href="https://mp.weixin.qq.com/s/1oDNxf5xHwlUUpJSVkqazg">通过几行 JS 就可以读取电脑上的所有数据？</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/A1uuU7DdBlUF-E6ZqlpOCw">百行代码带你实现通过872条Promise/A+用例的Promise</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/KIcn2TAwY58JGoWiz82Q2g">颜值爆表！Redis 官方可视化工具来啦，功能真心强大！</a></p><p>📒 程序员开源月刊《HelloGitHub》第 71 期</p><p><strong>C 项目</strong></p><p>chibicc：迷你 C 编译器。虽然它只是一个玩具级的编译器，但是实现了大多数 C11 特性，而且能够成功编译几十万行的 C 语言项目，其中包括 Git、SQLite 等知名项目。而且它项目结构清晰、每次提交都是精心设计、代码容易理解，对编译器感兴趣的同学可以从第一个提交开始学习</p><blockquote><p><a href="https://github.com/rui314/chibicc">https://github.com/rui314/chibicc</a></p></blockquote><p><strong>Go 项目</strong></p><p>nali：离线查询 IP 地理信息和 CDN 服务提供商的命令行工具</p><blockquote><p><a href="https://github.com/zu1k/nali">https://github.com/zu1k/nali</a></p></blockquote><p>revive：快速且易扩展的 Go 代码检查工具。它比 golint 更快、更灵活，深受广大 Go 开发者的喜爱</p><blockquote><p><a href="https://github.com/mgechev/revive">https://github.com/mgechev/revive</a></p></blockquote><p>go-chart：Go 原生图表库。支持折线图、柱状图、饼图等</p><blockquote><p><a href="https://github.com/wcharczuk/go-chart">https://github.com/wcharczuk/go-chart</a></p></blockquote><p><strong>Java 项目</strong></p><p>thingsboard：完全开源的物联网 IoT 平台。它使用行业的标准物联网协议 MQTT、CoAP 和 HTTP 连接设备，支持数据收集、处理、可视化和设备管理等功能。通过该项目可快速实现物联网平台搭建，从而成为众多大型企业的首选，行业覆盖电信、智慧城市、环境监测等</p><blockquote><p><a href="https://github.com/thingsboard/thingsboard">https://github.com/thingsboard/thingsboard</a></p></blockquote><p>from-java-to-kotlin：展示 Java 和 Kotlin 语法上差别的项目。让有 Java 基础的程序员可以快速上手 Kotlin</p><blockquote><p><a href="https://github.com/MindorksOpenSource/from-java-to-kotlin">https://github.com/MindorksOpenSource/from-java-to-kotlin</a></p></blockquote><p>⭐️ ⭐️ <a href="https://juejin.cn/post/7069555976717729805">「React进阶」react-router v6 通关指南</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[2月27日内容汇总]]></title>
        <id>2月27日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/2月27日内容汇总"/>
        <updated>2022-02-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 Vue diff 算法]]></summary>
        <content type="html"><![CDATA[<p>📒 Vue diff 算法</p><p>Vue2 diff 算法核心流程如下：</p><ul><li>diff 的入口函数为 <code>patch</code>，使用 <code>sameVnode</code> 比较节点是否相同，如相同则使用 <code>patchVnode</code> 继续进行深层比较，否则就使用 <code>createEle</code> 方法渲染出真实 DOM 节点，然后替换旧元素节点</li><li><code>sameVnode</code> 通过比较 <code>key</code> 值是否一样、标签名是否一样、是否都为注释节点、是否都定义 <code>data</code>、当标签为 <code>input</code> 时，<code>type</code> 是否相同来判断两个节点是否相同</li><li><code>patchVnode</code> 方法如何对节点深层比较<ul><li>拿到真实 DOM 的节点 <code>el</code>（即 <code>oldVnode.el</code>）</li><li>判断当前 <code>newVnode</code> 和 <code>oldVnode</code> 是否指向同一对象，如果是直接 <code>return</code></li><li>如果新旧虚拟节点是文本节点，且文本不一样，则直接将真实 DOM 中文本更新为新虚拟节点的文本；若文本没有变化，则继续对比新旧节点的 <code>children</code></li><li>如果 <code>oldVnode</code> 有子节点而 <code>newVnode</code> 没有，则删除 <code>el</code> 的子节点</li><li>如果 <code>oldVnode</code> 没有子节点而 <code>newVnode</code> 有，则将 <code>newVnode</code> 的子节点渲染出真实 DOM 添加到 <code>el</code>（Vue 源码中会判断是否有 <code>key</code> 重复）</li><li>如果两者都有子节点，则执行 <code>updateChildren</code> 函数比较子节点</li></ul></li><li><code>updateChildren</code> 是 diff 算法核心部分，当发现新旧虚拟节点的子节点都存在时，需要判断哪些节点是需要移动的，哪些节点是可以直接复用的，进而提高 diff 的效率<ul><li>通过 <strong>首尾指针法</strong>，在新旧子节点的首位定义四个指针，然后不断对比找到可复用的节点，同时判断需要移动的节点</li><li>非理想状态下只能通过节点映射的方式去找可复用节点，时间复杂度为 <code>O(n^2)</code></li><li>Vue3 的 diff 算法在非理想状态下的节点对比使用了最长递增子序列来处理，时间复杂度为 <code>O(nlgn)～O(n^2)</code></li></ul></li></ul><p><img src="./patch.png" alt="image"/></p><p><a href="https://mp.weixin.qq.com/s/8M-pJdKjF6bx5ijtSFKIcw">图解Diff算法——Vue篇</a></p><p><a href="https://juejin.cn/post/7067693810918096903">浅析 Snabbdom 中 vnode 和 diff 算法</a></p><p>📒 Leetcode 300 最长递增子序列</p><p>常规方式是使用动态规划，时间复杂度 <code>O(n^2)</code>。这里注意 <code>dp[i]</code> 的定义是 <strong>以 <code>nums[i]</code> 这个数结尾的最长递增子序列长度</strong>。</p><pre><code class="language-java">class Solution {
  public int lengthOfLIS(int[] nums) {
    // 定义 dp 数组
    // dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列长度
    int[] dp = new int[nums.length];
    // 初始值填充 1（子序列至少包含当前元素自己）
    Arrays.fill(dp, 1);
    for (int i = 0; i &lt; nums.length; i++) {
      for (int j = 0; j &lt; i; j++) {
        // 假设 dp[0...i-1] 都已知，需要求出 dp[i]
        // 只需要遍历 nums[0...i-1]，找到结尾比 nums[i] 小的子序列长度 dp[j]
        // 然后把 nums[i] 接到最后，就可以形成一个新的递增子序列，长度为 dp[j] + 1
        // 显然，可能形成很多种新的子序列，只需要选择最长的，作为 dp[i] 的值即可
        if (nums[i] &gt; nums[j]) {
          dp[i] = Math.max(dp[i], dp[j] + 1);
        }
      }
    }
    // 遍历 dp 数组，找出最大值
    int res = 0;
    for (int i = 0; i &lt; dp.length; i++) {
      res = Math.max(res, dp[i]);
    }
    return res;
  }
}
</code></pre><p>📒 CSS 中的 <code>object-fit</code> 属性用法</p><p>在项目中有一个需求，图片尺寸较小时，需要保存图片原有大小，图片尺寸大于容器大小时，需要缩放以适合容器大小，同时保持原有比例。</p><p>查阅 MDN 文档可知，在 <code>&lt;img&gt;</code> 和 <code>&lt;video&gt;</code> 等替换元素上可以使用 <code>object-fit</code> 属性，用于设置替换元素该如何适配容器，可以取以下几个值：</p><ul><li><code>object-fit: fill</code>：图片被拉伸以适应容器，这种方式不会保持长宽比</li><li><code>object-fit: contain</code>：图片被缩放以适应容器，同时保持长宽比，如果图片与容器长宽比不匹配，较短边会留出空白</li><li><code>object-fit: cover</code>：图片被缩放以适应容器，同时保持长宽比，如果图片与容器长宽比不匹配，较长边会被剪裁</li><li><code>object-fit: none</code>：图片不会调整大小</li><li><code>object-fit: scale-down</code>：图片较小时使用 <code>none</code>，图片较大时使用 <code>contain</code></li></ul><p>综上，使用 <code>object-fit: scale-down</code> 就可以实现项目需求。</p><blockquote><p>注意 IE 11 不支持 <code>object-fit</code></p></blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit">object-fit - MDN</a></p><p>📒 理解归并排序</p><p>归并排序就是对数组的左半边和右半边分别排序，然后再合并两个有序数组。</p><ul><li>归并排序的过程可以在逻辑上抽象成一棵二叉树，树上的每个节点的值可以认为是 <code>nums[lo..hi]</code>，叶子节点的值就是数组中的单个元素</li><li>然后，在每个节点的后序位置（左右子节点已经被排好序）的时候执行 <code>merge</code> 函数，合并两个子节点上的子数组</li><li>这个 <code>merge</code> 操作会在二叉树的每个节点上都执行一遍，执行顺序是二叉树后序遍历的顺序</li></ul><blockquote><p>一句话总结，归并排序实际上就是先对数组不断进行二分，分到只有一个元素为止，此时 <code>merge</code> 方法开始发挥作用，将两个元素为一组，合并为长度为 2 的有序数组，再将两个长度为 2 的有序数组为一组，合并为长度为 4 的有序数组，以此类推</p></blockquote><pre><code class="language-java">class Merge {

  // 用于辅助合并有序数组（不能原地合并，需要借助额外空间）
  private static int[] temp;

  public static void sort(int[] nums) {
    // 避免递归中频繁分配和释放内存可能产生的性能问题
    // 提前给辅助数组开辟内存空间
    temp = new int[nums.length];
    // 原地修改的方式对整个数组进行排序
    sort(nums, 0, nums.length - 1);
  }

  // 定义：将子数组 nums[lo..hi] 进行排序
  private static void sort(int[] nums, int lo, int hi) {
    if (lo == hi) {
      // 单个元素不用排序
      return;
    }
    // 这样写是为了防止溢出，效果等同于 (hi + lo) / 2
    // 注意：对于无法整除的情况，Java 中 int 类型会自动向下取整
    int mid = lo + (hi - lo) / 2;
    // 先对左半部分数组 nums[lo..mid] 排序
    sort(nums, lo, mid);
    // 再对右半部分数组 nums[mid+1..hi] 排序
    sort(nums, mid + 1, hi);
    // 将两部分有序数组合并成一个有序数组
    merge(nums, lo, mid, hi);
  }

  // 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组
  private static void merge(int[] nums, int lo, int mid, int hi) {
    // 先把 nums[lo..hi] 复制到辅助数组中
    // 以便合并后的结果能够直接存入 nums
    for (int i = lo; i &lt;= hi; i++) {
      temp[i] = nums[i];
    }

    // 数组双指针技巧，合并两个有序数组
    // i =&gt; 左半边数组起始下标
    // j =&gt; 右半边数组起始下标
    int i = lo, j = mid + 1;
    for (int p = lo; p &lt;= hi; p++) {
      if (i == mid + 1) {
        // 左半边数组已全部被合并，只需把右半边数组合并过来即可
        nums[p] = temp[j++];
      } else if (j == hi + 1) {
        // 右半边数组已全部被合并，只需把左半边数组合并过来即可
        nums[p] = temp[i++];
      } else if (temp[i] &gt; temp[j]) {
        // 将较小的元素合入，同时下标前进一位，此时是升序
        // 只要将 &gt; 改为 &lt; 就可以把结果改为降序
        nums[p] = temp[j++];
      } else {
        nums[p] = temp[i++];
      }
    }
  }
}
</code></pre><blockquote><p>归并排序时间复杂度为 <code>O(nlogn)</code></p></blockquote><p><a href="https://mp.weixin.qq.com/s/7_jsikVCARPFrJ6Hj1EYsg">归并排序的正确理解方式及运用</a></p><p>🌛 Leetcode 112 路径总和</p><p>判断是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><pre><code class="language-java">class Solution {
  public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) return false;
    if (root.left == null &amp;&amp; root.right == null) {
      return (targetSum - root.val) == 0;
    }
    boolean leftResult = hasPathSum(root.left, targetSum - root.val);
    boolean rightResult = hasPathSum(root.right, targetSum - root.val);
    return leftResult || rightResult;
  }
}
</code></pre><p>📒 <a href="https://mp.weixin.qq.com/s/Pq6eFNxjWpFIGdSL3ya7Vg">Podman 已成 Linux 官方标配！Docker 没戏了？</a></p><p>⭐️ <a href="https://juejin.cn/post/7000909761336049671">不懂动态规划？21道 LeetCode题目带你学会动态规划！</a></p><p>⭐️ <a href="https://juejin.cn/post/7067693810918096903">浅析 Snabbdom 中 vnode 和 diff 算法</a></p><p>📒 HTTP 缓存最佳实践</p><p>在配置 nginx 的时候，可以配置合理的缓存策略，例如：</p><ul><li>html 文件配置协商缓存</li><li>js、css、图片、字体等文件由于带有哈希，可以配置一年强缓存</li></ul><p>:::tip</p><p>这里的缓存更新逻辑：</p><p>当 js、css 等静态资源文件修改后，文件哈希发生变化，对应引入 html 的文件地址也发生变化，等于 html 文件也被修改。因此浏览器端会获取到最新的 html 文件，然后根据带有哈希的路径加载最新的静态资源文件。</p><p>:::</p><p>这样配置缓存之后，可以极大提升资源二次加载速度，进而提升用户体验。以上这些是从性能角度考虑的，从安全角度考虑，推荐如下配置：</p><ul><li>为了防止中介缓存，建议设置 <code>Cache-Control: private</code>，这可以禁用掉所有 <code>Public Cache</code>（比如代理），这就减少了攻击者跨界访问到公共内存的可能性</li><li>默认情况下，浏览器使用 <strong>URL</strong> 和 <strong>请求方法</strong> 作为缓存 key，这意味着，如果一个网站需要登录，不同用户的请求由于它们的请求URL和方法相同，数据会被缓存到一块内存里。如果我们请求的响应是跟请求的 <code>Cookie</code> 相关的，建议设置 <code>Vary: Cookie</code> 作为二级缓存 key</li></ul><p><a href="https://mp.weixin.qq.com/s/43pa04szJ2zU_IyVP4LraQ">HTTP 缓存别再乱用了！推荐一个缓存设置的最佳姿势！</a></p><p>📒 跨域，不止CORS</p><p>通常提到跨域问题的时候，相信大家首先会想到的是 <code>CORS</code> (Cross Origin Resource Sharing)，其实 <code>CORS</code> 只是众多跨域访问场景中安全策略的一种，类似的策略还有：</p><ul><li><code>COEP (Cross Origin Embedder Policy)</code>：跨源嵌入程序策略</li><li><code>COOP (Cross Origin Opener Policy)</code>：跨源开放者政策</li><li><code>CORP (Cross Origin Resource Policy)</code>：跨源资源策略</li><li><code>CORB (Cross Origin Read Blocking)</code>：跨源读取阻止</li></ul><p>为何有时候服务端没有给响应头设置 <code>Content-Type</code>，浏览器还能正确识别资源类型</p><p>当服务端没有设置 <code>Content-Type</code> 或者浏览器认为类型不正确时，浏览器会读取资源的字节流，进行 <strong>MIME 类型嗅探</strong>。这就可能导致一些敏感数据被提交到内存，攻击者随后可以利用 <code>Spectre</code> 之类的漏洞来潜在地读取该内存块。</p><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#mime_sniffing">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#mime_sniffing</a></p></blockquote><p>为了使我们的网站更加安全，建议所有网站都开启 <code>CORB</code>，只需要下面的操作：</p><ul><li>配置正确的 <code>Content-Type</code>（例如，HTML 资源设置 <code>text/html</code>）</li><li>开启 <code>X-Content-Type-Options: nosniff</code> 来禁止客户端进行自动 MIME 嗅探</li></ul><p><a href="https://mp.weixin.qq.com/s/k9_7Oc1zrQe6LMJB6D0qig">跨域，不止CORS</a></p><p><a href="https://juejin.cn/post/6855129007906963464">新的跨域策略：使用COOP、COEP为浏览器创建更安全的环境</a></p><p>📒 如何监听系统黑暗模式</p><p>在 CSS 中可以通过 <code>prefers-color-scheme</code> 媒体查询实现：</p><pre><code class="language-css">body {
  color: black;
  background: white;
}
@media (prefers-color-scheme: dark) {
  body {
    color: white;
    background: black;
  }
}
</code></pre><p>在 JS 中可以使用 <code>window.matchMedia</code> 媒体查询：</p><pre><code class="language-ts">import React from &quot;react&quot;;

export type ThemeName = &quot;light&quot; | &quot;dark&quot;;

function useTheme() {
  const [themeName, setThemeName] = React.useState&lt;ThemeName&gt;(&quot;light&quot;);

  React.useEffect(() =&gt; {
    // 设置初始皮肤
    if (window.matchMedia(&quot;(prefers-color-scheme: dark)&quot;).matches) {
      setThemeName(&quot;dark&quot;);
    } else {
      setThemeName(&quot;light&quot;);
    }
    
    // 监听系统颜色切换
    window
      .matchMedia(&quot;(prefers-color-scheme: dark)&quot;)
      .addEventListener(&quot;change&quot;, (event) =&gt; {
        if (event.matches) {
          setThemeName(&quot;dark&quot;);
        } else {
          setThemeName(&quot;light&quot;);
        }
      });
  }, []);

  return {
    themeName,
    isDarkMode: themeName === &quot;dark&quot;,
    isLightMode: themeName === &quot;light&quot;,
  }
}
</code></pre><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia</a></p></blockquote><blockquote><p>自定义 hook 实际上就是 mixin，把一段可复用的逻辑抽离出来</p></blockquote><p>📒 搜索 JS、Go、Java、Python 的第三方库</p><p><a href="https://openbase.com/">https://openbase.com/</a></p><p>例如搜索 Redux 的替代方案：</p><p><a href="https://openbase.com/js/redux/alternatives">https://openbase.com/js/redux/alternatives</a></p><p>⭐️ <a href="https://juejin.cn/post/7065875157268561957">React hooks 状态管理方案解析</a></p><p>📒 深入理解 React Native 的新架构</p><p>照 React Native 团队去年发表的一篇 博客 的说法，他们会在今年发布新的架构。本文将会详细介绍新架构的相关内容。</p><blockquote><p><a href="https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd">https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd</a></p></blockquote><p>📒 QUIC——快速UDP网络连接协议</p><ul><li>QUIC 的Stream流基于Stream ID+Offset进行包确认，流量控制需要保证所发送的所有包offset小于 <strong>最大绝对字节偏移量 （ maximum absolute byte offset ）</strong>， 该值是基于当前 <strong>已经提交的字节偏移量（offset of data consumed）</strong> 而进行确定的，QUIC会把连续的已确认的offset数据向上层应用提交。QUIC支持乱序确认，但本身也是按序（offset顺序）发送数据包</li><li>QUIC利用ack frame来进行数据包的确认，来保证可靠传输。一个ack frame只包含多个确认信息，没有正文</li><li>如果数据包N超时，发送端将超时数据包N重新设置编号M（即下一个顺序的数据包编号） 后发送给接收端</li><li>在一个数据包发生超时后，其余的已经发送的数据包依旧可以基于Offset得到确认，避免了TCP利用SACK才能解决的重传问题</li></ul><p>:::tip</p><p>其实QUIC的乱序确认设计思想并不新鲜，大量网络视频流就是通过类似的基于UDP的RUDP、RTP、UDT等协议来实现快速可靠传输的。他们同样支持乱序确认，所以就会导致这样的观看体验：明明进度条显示还有一段缓存，但是画面就是卡着不动了，如果跳过的话视频又能够播放了</p><p>:::</p><p><a href="https://juejin.cn/post/7066993430102016037">QUIC——快速UDP网络连接协议</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[2月20日内容汇总]]></title>
        <id>2月20日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/2月20日内容汇总"/>
        <updated>2022-02-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 一致性哈希算法解决的问题]]></summary>
        <content type="html"><![CDATA[<p>📒 一致性哈希算法解决的问题</p><ul><li>大多数网站都是 <strong>多节点部署</strong>，需要根据不同场景使用不同的 <strong>负载均衡策略</strong></li><li>最简单的算法就是使用 <strong>加权轮询</strong>，这种场景建立在每个节点存储的数据都是相同的前提下，访问任意一个节点都能得到结果</li><li>当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。加权轮询算法是无法应对「分布式系统」的，因为分布式系统中，每个节点存储的数据是不同的，不是说任意访问一个节点都可以得到缓存结果的</li><li>这种场景可以使用 <strong>哈希算法</strong>，对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 key 映射到一个节点了，可以满足分布式系统的负载均衡需求</li><li>哈希算法最简单的做法就是进行取模运算，比如分布式系统中有 3 个节点，基于 <code>hash(key) % 3</code> 公式对数据进行了映射，如果计算后得到的值是 0，就说明该 key 需要去第一个节点获取</li><li>但是哈希算法存在一个问题，如果 <strong>节点数量发生了变化，也就是在对系统做扩容或者缩容时</strong>，意味取模哈希函数中基数的变化，这样会导致 <strong>大部分映射关系改变</strong>，必须迁移改变了映射关系的数据，否则会出现查询不到数据的问题</li><li>假设总数据条数为 M，哈希算法在面对节点数量变化时，<strong>最坏情况下所有数据都需要迁移，所以它的数据迁移规模是 O(M)</strong>，这样数据的迁移成本太高了</li><li>一致性哈希算法就很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题</li></ul><p><a href="https://juejin.cn/post/7067012046256078885">微信一面：什么是一致性哈希？用在什么场景？解决了什么问题？</a></p><p>📒 前端项目 nginx 配置总结</p><p>有段时间没搞项目部署了，结果最近有同事在部署前端项目的时候，访问页面路由，响应都是 404，排查了半天，这里再总结一下。</p><p>前端单页应用路由分两种：哈希模式和历史模式。</p><p>哈希模式部署不会遇到啥问题，但是一般只用于本地调试，没人直接部署到生产环境。历史模式的路由跳转通过 <code>pushState</code> 和 <code>replaceState</code> 实现，不会触发浏览器刷新页面，不会给服务器发送请求，且会触发 <code>popState</code> 事件，因此可以实现纯前端路由。</p><p>需要注意，使用历史模式的时候，还是有两种情况会导致浏览器发送请求给服务器：</p><ul><li>输入地址直接访问</li><li>刷新页面</li></ul><p>在这两种情况下，如果当前地址不是根路径，因为都是前端路由，服务器端根本不存在对应的文件，则会直接导致服务器直接响应 404。因此需要在服务器端进行配置：</p><pre><code class="language-nginx">server {
  listen 80;
  server_name www.bili98.com;
  location / {
    root /root/workspace/ruoyi-ui/dist;

    # history 模式重点就是这里
    try_files $uri $uri/ /index.html;
  }
}
</code></pre><p>:::tip</p><p><code>try_files</code> 的作用就是按顺序检查文件是否存在，返回第一个找到的文件。<code>$uri</code> 是 nginx 提供的变量，指当前请求的 URI，不包括任何参数</p><p>当请求静态资源文件的时候，命中 <code>$uri</code> 规则；当请求页面路由的时候，命中 <code>/index.html</code> 规则</p><p>:::</p><p>此外，在部署的时候不使用根路径，例如希望通过这样的路径去访问 <code>/i/top.gif</code>，如果直接修改 <code>location</code> 发现还会响应 404：</p><pre><code class="language-nginx">location /i/ {
  root /data/w3;
  try_files $uri $uri/ /index.html;
}
</code></pre><blockquote><p>这是因为 <code>root</code> 是直接拼接 <code>root</code> + <code>location</code>，访问 <code>/i/top.gif</code>，实际会查找 <code>/data/w3/i/top.gif</code> 文件</p></blockquote><p>这种情况下推荐使用 <code>alias</code>：</p><pre><code class="language-nginx">location /i/ {
  alias /data/w3;
  try_files $uri $uri/ /index.html;
}
</code></pre><blockquote><p><code>alias</code> 是用 <code>alias</code> 替换 <code>location</code> 中的路径，访问 <code>/i/top.gif</code>，实际会查找 <code>/data/w3/top.gif</code> 文件</p></blockquote><p>现在页面部署成功了，但是接口请求会出错，这是因为还没有对接口请求进行代理，下面配置一下：</p><pre><code class="language-nginx">location ^~ /prod-api/ {
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header REMOTE-HOST $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_pass http://192.168.31.101:8080/;
}
</code></pre><p>完整的 nginx 配置如下：</p><pre><code class="language-nginx">server {
  listen 80;
  server_name www.bili98.com;

  location /ruoyi/ {
    # 支持 /ruoyi 子路径访问
    alias /root/workspace/ruoyi-ui/dist;

    # history 模式重点就是这里
    try_files $uri $uri/ /index.html;

    # html 文件不可设置强缓存，设置协商缓存即可
    add_header Cache-Control &#x27;no-cache, must-revalidate, proxy-revalidate, max-age=0&#x27;;
  }

  # 接口请求代理
  location ^~ /prod-api/ {
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header REMOTE-HOST $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_pass http://192.168.31.101:8080/;
  }

  location ~* \.(?:css(\.map)?|js(\.map)?|gif|svg|jfif|ico|cur|heic|webp|tiff?|mp3|m4a|aac|ogg|midi?|wav|mp4|mov|webm|mpe?g|avi|ogv|flv|wmv)$ {
    # 静态资源设置一年强缓存
    add_header Cache-Control &#x27;public, max-age=31536000&#x27;;
  }
}
</code></pre><p>location 的匹配规则：</p><ul><li><code>=</code> 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。</li><li><code>^~</code> 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。</li><li><code>~</code> 表示该规则是使用正则定义的，区分大小写。</li><li><code>~*</code> 表示该规则是使用正则定义的，不区分大小写。</li></ul><p>nginx 的匹配优先顺序按照上面的顺序进行优先匹配，而且 <strong>只要某一个匹配命中直接退出，不再进行往下的匹配</strong>。</p><p>剩下的普通匹配会按照 <strong>最长匹配长度优先级来匹配</strong>，就是谁匹配的越多就用谁。</p><p><a href="https://juejin.cn/post/7064378702779891749">前端到底用nginx来做啥</a></p><p><a href="https://juejin.cn/post/7048952689601806366">一份简单够用的 Nginx Location 配置讲解</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/Bkss0lzPT-TI6GyGxMyn3Q">零基础理解 PostCSS 的主流程</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/tQLG0HzR0bR_A8NLjTIChQ">Jest + React Testing Library 单测总结</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/UyvRTVWZDYnEBV9SL2Bbpg">使用lerna管理monorepo及发npm包实战教程</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/DswfPb6J1w2B_MWj1TjyOg">从源码中来，到业务中去，React性能优化终极指南</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/AfCfqhZy70v6MrSVt5_8uw">React核心设计原理--（React Fiber）异步执行调度</a></p><p>📒 如何在浏览器使用后端语言进行编程</p><p>你可能会认为这是关于使用 WebAssembly 在浏览器中运行 Python 之类的代码，但这并不是作者想分享的。作者提到的是通过服务端的 WebSocket 连接浏览器平台，由服务端处理 HTML 渲染更新到浏览器，这种方案日益流行，并且已经在 Elixir 和 Rails 全栈框架中支持。</p><blockquote><p><a href="https://github.com/readme/featured/server-side-languages-for-front-end">https://github.com/readme/featured/server-side-languages-for-front-end</a></p></blockquote><p>📒 正则表达式如何实现千分位分隔符</p><p>实现如下的需求：</p><ul><li>从后往前每三个数字前加一个逗号</li><li>开头不能加逗号</li></ul><p>这样看起来非常符合 <code>(?=p)</code> 的规律，<code>p</code> 可以表示每三个数字，要添加逗号所处的位置正好是 <code>(?=p)</code> 匹配出来的位置。</p><p>第一步，先尝试把最后一个逗号弄出来：</p><pre><code class="language-js">&quot;300000000&quot;.replace(/(?=\d{3}$)/, &quot;,&quot;)
// &#x27;300000,000&#x27;
</code></pre><p>第二步，把所有逗号都弄出来：</p><pre><code class="language-js">&quot;300000000&quot;.replace(/(?=(\d{3})+$)/g, &quot;,&quot;)
// &#x27;,300,000,000&#x27;
</code></pre><blockquote><p>使用括号把一个 <code>p</code> 模式变成一个整体</p></blockquote><p>第三步，去掉首位的逗号：</p><pre><code class="language-js">&quot;300000000&quot;.replace(/(?!^)(?=(\d{3})+$)/g, &quot;,&quot;)
// &#x27;300,000,000&#x27;
</code></pre><p>⭐️ <a href="https://juejin.cn/post/7065197280223035422">如何使用高阶函数编程提升代码的简洁性</a></p><p>📒 React Router v6 和私有路由 (也称作保护路由)</p><blockquote><p><a href="https://www.robinwieruch.de/react-router-private-routes/">https://www.robinwieruch.de/react-router-private-routes/</a></p></blockquote><p>📒 React Router v6 的身份验证简介</p><p>在一个简单的示例应用程序中，通过 React Router v6 实现身份验证的实用演练。</p><blockquote><p><a href="https://www.robinwieruch.de/react-router-authentication/">https://www.robinwieruch.de/react-router-authentication/</a></p></blockquote><p>📒 Etsy 从 React 15.6 迁移到了 Preact （而不是 React 16）</p><p>在这篇 关于在 Etsy 更新 React 的文章中，对这个决定有一个完整的解释。但事实证明，拥有相同 API 的小型 React 替代品 Preact 是他们的正确选择。</p><blockquote><p><a href="https://twitter.com/sangster/status/1486382892326563845">https://twitter.com/sangster/status/1486382892326563845</a></p></blockquote><p>📒 Promise 两点总结</p><p>不建议在 <code>Promise</code> 里面使用 <code>try...catch</code>，这样即使 <code>Promise</code> 内部报错，状态仍然是 <code>fullfilled</code>，会进入 <code>then</code> 方法回调，不会进入 <code>catch</code> 方法回调。</p><pre><code class="language-js">function request() {
  return new Promise((resolve, reject) =&gt; {
    try {
      // ...
      resolve(&quot;ok&quot;);
    } catch(e) {
      console.log(e);
    }
  })
}

request()
  .then(res =&gt; {
    console.log(&quot;请求结果：&quot;, res);
  })
  .catch(err =&gt; {
    // 由于在 Promise 中使用了 try...catch
    // 因此即使 Promise 内部报错，也不会被 catch 捕捉到
    console.log(err);
  })
</code></pre><blockquote><p><code>Promise</code> 内部的异常，老老实实往外抛就行，让 <code>catch</code> 方法来处理，符合单一职责原则</p></blockquote><p>不建议在 <code>async</code> 函数中，既不使用 <code>await</code>，也不使用 <code>return</code>，这样就算内部的 <code>Promise</code> reject 也无法捕捉到：</p><pre><code class="language-js">async function handleFetchUser(userList) {
  // 这里既没有使用 await，也没有使用 return
  Promise.all(userList.map(u =&gt; request(u)));
}

handleFetchUser(userList)
  .then(res =&gt; {
    // 由于没有返回值，这里拿到的是 undefined
    console.log(res);
  })
  .catch(err =&gt; {
    // 即使 handleFetchUser 内部的 Promise reject
    // async 函数返回的 Promise 仍然是 fullfilled
    // 此时仍然会进入 then 方法回调，无法被 catch 捕捉到
    console.log(err);
  })
</code></pre><blockquote><p>如果确实有这种需求，建议不要使用 <code>async</code> 函数，直接改用普通函数即可</p></blockquote><p>📒 Rollup 配置</p><p><a href="https://juejin.cn/post/6844903970469576718">前端组件/库打包利器rollup使用与配置实战</a></p><p>📒 Docker 使用，Gitlab CI 实践</p><p><a href="https://juejin.cn/post/7064906701941506061">GitLab CI 从入门到实践</a></p><p>📒 总结一下 Babel 插件开发基本操作</p><blockquote><p><a href="https://github.com/BoBoooooo/AST-Learning">https://github.com/BoBoooooo/AST-Learning</a></p></blockquote><p>📒 <a href="https://juejin.cn/post/7064909191210598408">记一次 Vue2 迁移 Vue3 的实践总结</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[2月13日内容汇总]]></title>
        <id>2月13日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/2月13日内容汇总"/>
        <updated>2022-02-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 浏览器技术架构的演进过程和背景]]></summary>
        <content type="html"><![CDATA[<p>📒 <a href="https://juejin.cn/post/7035791029814951950">浏览器技术架构的演进过程和背景</a></p><p>📒 <a href="https://juejin.cn/post/7059408852390772767">从chromium源码来窥探浏览器的渲染</a></p><p>📒 <a href="https://juejin.cn/post/6951649464637636622">从 0 开始手把手带你搭建一套规范的 Vue3.x 项目工程环境</a></p><p>📒 为什么 React 中要使用 immutable 数据流</p><p>在 <code>PureComponent</code> 和 <code>memo</code> 中会将新旧 props 进行 <strong>浅层比对</strong>，逻辑非常简单：</p><pre><code class="language-js">function shallowEqual (objA: mixed, objB: mixed): boolean {
  // 下面的 is 相当于 === 的功能
  // 只是对 + 0 和 - 0，以及 NaN 和 NaN 的情况进行了特殊处理
  // 第一关：基础数据类型直接比较出结果
  if (is (objA, objB)) {
    return true;
  }
  // 第二关：只要有一个不是对象数据类型就返回 false
  if (
    typeof objA !== &#x27;object&#x27; ||
    objA === null ||
    typeof objB !== &#x27;object&#x27; ||
    objB === null
  ) {
    return false;
  }

  // 第三关：在这里已经可以保证两个都是对象数据类型，比较两者的属性数量
  const keysA = Object.keys (objA);
  const keysB = Object.keys (objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // 第四关：比较两者的属性是否相等，值是否相等
  for (let i = 0; i &lt; keysA.length; i++) {
    if (
      !hasOwnProperty.call (objB, keysA [i]) ||
      !is (objA [keysA [i]], objB [keysA [i]])
    ) {
      return false;
    }
  }

  return true;
}
</code></pre><p>但浅层比较相当于只是比较第一层，还是会存在一些问题，如果修改深层嵌套的对象，浅层比较会认为相等。</p><p>为解决这个问题，可以手动在 <code>shouldComponentUpdate</code> 钩子中实现深层比对，但缺点就是浪费性能。最好的解决方案就是使用 immutable 数据流。immutable 对象内部采用的是多叉树的结构，只要有节点被修改，那么该节点和与之相关的所有父节点会直接拷贝到一个新的对象中（创建一个新的引用）。也就是说，修改任意一个子节点，改动都会冒泡到根节点，这样浅比较就能感知到数据改变了。</p><p><a href="https://juejin.cn/book/6844733816460804104/section/6844733816548884487">React Hooks 与 Immutable 数据流实战</a></p><p>📒 操作 JavaScript 的 AST</p><p><code>acorn</code>、<code>Espree</code>、<code>@babel/parser</code> 三种解析器用法说明</p><p><a href="https://juejin.cn/post/7061808830274863118">操作 JavaScript 的 AST</a></p><p>📒 React fiber 架构浅析</p><p>在 React 16 之前，vdom 以递归的方式进行 patch 和渲染，一个 vdom 节点可以表示如下：</p><pre><code class="language-ts">class VNode {
  type: string;
  props: Record&lt;string, any&gt;;
  children: VNode[];
}
</code></pre><p>在 React 16 之后引入了 fiber 架构，vdom 不再直接渲染，而是先转成 fiber，一个 fiber 节点可以表示如下：</p><pre><code class="language-ts">class FiberNode {
  type: string;
  props: Record&lt;string, any&gt;;
  dom: HTMLElement; // 提前创建 dom 节点
  child?: FiberNode;
  sibling?: FiberNode;
  return?: FiberNode;
  effectTag: string; // 做 diff，确定是增、删还是改
}
</code></pre><p>在 fiber 架构中，将 vdom 树结构转成了链表，每个 fiber 节点的 <code>child</code> 关联第一个子节点，然后通过 <code>sibling</code> 串联同一层级的节点，所有的节点可以 <code>return</code> 到父节点：</p><p><img src="./react-fiber.png" alt="image"/></p><p>先把 vdom 转 fiber，也就是 reconcile 的过程，因为 fiber 是链表，就可以打断，用 schedule 来空闲时调度（requestIdleCallback）就行，最后全部转完之后，再一次性 render，这个过程叫做 commit。</p><p>schedule 就是通过空闲调度每个 fiber 节点的 reconcile（vdom 转 fiber），全部 reconcile 完了就执行 commit。</p><p>reconcile 除了将 vdom 转 fiber 外，还会做两件事：一个是 <strong>提前创建对应的 dom 节点</strong>，另一个是 <strong>做 diff，确定是增、删还是改</strong>，通过 schdule 的调度，最终把整个 vdom 树转成了 fiber 链表。</p><p>commit 就是对 dom 的增删改，把 reconcile 产生的 fiber 链表一次性添加到 dom 中，因为 dom 节点都提前创建好了、是增是删还是改也都知道了，所以这个阶段很快。每个 fiber 节点的渲染就是按照 child、sibling 的顺序以此插入到 dom 中，这里每个 fiber 节点都要往上找它的父节点（之前保存的 <code>return</code> 指针），因为我们只是新增，那么只需要 <code>appendChild</code> 就行。</p><p><a href="https://juejin.cn/post/7063321486135656479">手写简易版 React 来彻底搞懂 fiber 架构</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/Hnp2XddZPp3WAHrXBqEyAQ">Chrome 99新特性：@layers 规则浅析</a></p><p>📒 WebVM.io：基于 Web 的“无服务端”虚拟 Linux 环境</p><p>浏览器端运行的 Linux 环境，基于 JavaScript 和 WebAssembly 的 CheerpX x86 虚拟化引擎驱动。虽然它不是一个完全基于 JavaScript 的项目，但它很好地展示了 Web 技术的发展程度。它已经内置了 Node v10.24.0，但要注意它首次加载速度可能会有点慢。</p><blockquote><p><a href="https://webvm.io/">https://webvm.io/</a></p></blockquote><p>这里有一篇关于它如何工作的文章。</p><blockquote><p><a href="https://leaningtech.com/webvm-server-less-x86-virtual-machines-in-the-browser/">https://leaningtech.com/webvm-server-less-x86-virtual-machines-in-the-browser/</a></p></blockquote><p>📒 如何使用 Vue 3、Vite、Pinia 开发应用程序</p><p>非常完善的开发、测试、部署指南。</p><blockquote><p><a href="https://labs.pineview.io/learn-how-to-build-test-and-deploy-a-single-page-app-with-vue-3-vite-and-pinia/">https://labs.pineview.io/learn-how-to-build-test-and-deploy-a-single-page-app-with-vue-3-vite-and-pinia/</a></p></blockquote><p>📒 用代码分割来提高打包 JavaScript 时的性能</p><blockquote><p><a href="https://www.smashingmagazine.com/2022/02/javascript-bundle-performance-code-splitting/">https://www.smashingmagazine.com/2022/02/javascript-bundle-performance-code-splitting/</a></p></blockquote><p>📒 提升 VSCode 扩展插件的运行速度</p><p>插件开发者必读</p><p><img src="./vscode-arch.webp" alt="image"/></p><blockquote><p><a href="https://jason-williams.co.uk/speeding-up-vscode-extensions-in-2022">https://jason-williams.co.uk/speeding-up-vscode-extensions-in-2022</a></p></blockquote><p>📒 Babel 发布 v7.17.0</p><p>该版本对 <strong>装饰器提案</strong> 的支持已稳定，还对装饰器的解析和转换进行了支持。</p><blockquote><p><a href="https://babeljs.io/blog/2022/02/02/7.17.0">https://babeljs.io/blog/2022/02/02/7.17.0</a></p></blockquote><p>📒 使用 Streams 模块构建高性能的 Node 应用</p><blockquote><p><a href="https://blog.appsignal.com/2022/02/02/use-streams-to-build-high-performing-nodejs-applications.html">https://blog.appsignal.com/2022/02/02/use-streams-to-build-high-performing-nodejs-applications.html</a></p></blockquote><p>📒 Node.js 新增 Fetch API</p><p>对 Fetch API （一般是浏览器端用来获取资源）的支持已经合并到 Node.js，将在提供 <code>‑‑experimental‑fetch</code> 标志后可以开启，Node v18 或者更高版本会默认启用。</p><blockquote><p><a href="https://fusebit.io/blog/node-fetch/">https://fusebit.io/blog/node-fetch/</a></p></blockquote><p>⭐️ <a href="https://mp.weixin.qq.com/s/triP_hXILSWq37DIGz4VNg">来自未来，2022 年的前端人都在做什么?</a></p><p>⭐️ <a href="https://juejin.cn/post/7052918009555320839">最全的前端性能定位总结</a></p><p>📒 <a href="https://juejin.cn/post/7061556434692997156">接近天花板的TS类型体操，看懂你就能玩转TS了</a></p><p>📒 <a href="https://juejin.cn/post/7057325585705467918">2022年必会Vue3.0学习 （强烈建议）</a></p><p>📒 <a href="https://juejin.cn/post/7062496975454732301">如何利用 SCSS 实现一键换肤</a></p><p>📒 <a href="https://juejin.cn/post/7062258342546620423">手写 JS 引擎来解释一道赋值面试题</a></p><p>📒 10 分钟讲述 React 的故事</p><blockquote><p><a href="https://www.youtube.com/watch?v=Wm_xI7KntDs">https://www.youtube.com/watch?v=Wm_xI7KntDs</a></p></blockquote><p>📒 2022 年值得关注的 React 趋势</p><blockquote><p><a href="https://www.chakshunyu.com/blog/what-you-should-definitely-look-out-for-in-react-in-2022/">https://www.chakshunyu.com/blog/what-you-should-definitely-look-out-for-in-react-in-2022/</a></p></blockquote><p>📒 React 18 中的自动批处理（Automatic Batching）</p><blockquote><p><a href="https://blog.bitsrc.io/automatic-batching-in-react-18-what-you-should-know-d50141dc096e?gi=aa52794e9a07">https://blog.bitsrc.io/automatic-batching-in-react-18-what-you-should-know-d50141dc096e?gi=aa52794e9a07</a></p></blockquote><p>📒 <a href="https://github.com/signavio/react-mentions">React Mentions：在 Textarea 中提及某人</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[2月6日内容汇总]]></title>
        <id>2月6日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/2月6日内容汇总"/>
        <updated>2022-02-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 很多人上来就删除的 package.json，还有这么多你不知道的]]></summary>
        <content type="html"><![CDATA[<p>📒 <a href="https://segmentfault.com/a/1190000039684460">很多人上来就删除的 package.json，还有这么多你不知道的</a></p><p>📒 React hooks 使用注意事项</p><p>惰性初始化 State：</p><pre><code class="language-jsx">// React hook 会在每次组件重新渲染的时候调用
const [count, setCount] = React.useState(ExpensiveCal());

// 如果 useState 的初始值需要通过复杂计算获取，可以传入一个函数惰性初始化
// 这个函数只会在组件挂载的时候执行一次，后续更新都不会执行
const [count, setCount] = React.useState(() =&gt; ExpensiveCal());
</code></pre><p>不需要视图渲染的变量，不要用 <code>useState</code>：</p><pre><code class="language-tsx">const App: React.FC&lt;{}&gt; = () =&gt; {
    // count 与视图渲染无关
    // 如果使用 useState，每次 count 变化都会触发组件重新渲染
    const [count, setCount] = React.useState(0);
    // 这里推荐使用 useRef
    const count = React.useRef(0);

    const handleClick = () =&gt; setCount(c =&gt; c + 1);

    return (
        &lt;button onClick={handleClick}&gt;Counter&lt;/button&gt;
    )
}
</code></pre><p>函数式更新：</p><pre><code class="language-jsx">const [count, setCount] = React.useState(0);

// 下面这样虽然调用了两次
// 但由于一次渲染中获取的 count 都是闭包中老的值
// 因此最终 count 还是 1
setCount(count + 1);
setCount(count + 1);

// 如果要获取到上一次更新的值，可以使用函数式更新
// 最终 count 为 2
setCount(c =&gt; c + 1);
setCount(c =&gt; c + 1);
</code></pre><p><code>useEffect</code> 清除副作用：</p><pre><code class="language-jsx">React.useEffect(() =&gt; {
    // ...
    return () =&gt; {
        // useEffect 的回调函数中可以返回一个函数
        // 这个函数会在组件卸载的时候执行
        // 用于清理各种事件监听器、定时器等
    }
}, []);
</code></pre><p><code>React.useCallback</code> 需要配合 <code>React.memo</code> 使用，其中任意一个单独使用是没用的。</p><p>:::tip</p><p><code>React.useCallback</code> 使用的一个场景是：</p><ul><li>一个父组件中有一个复杂的自定义组件，需要传入事件处理函数作为 prop，为避免父组件渲染导致该子组件重新渲染，使用 <code>React.memo</code> 包裹一下；</li><li>包裹之后发现父组件重新渲染，该子组件还是会重新渲染，这是因为事件处理函数在父组件每次渲染的时候都重新生成，因而传入子组件的 prop 变化导致 <code>React.memo</code> 失效；</li><li>将事件处理函数用 <code>React.useCallback</code> 包裹一下，对事件处理函数进行缓存，避免每次父组件渲染都重新生成，这样父组件重新渲染就不会导致子组件重新渲染；</li><li>需要注意 <code>React.useCallback</code> 缓存本身也是有性能开销的，因此只有在子组件渲染比较昂贵的时候，才进行缓存处理；</li></ul><p>:::</p><p>📒 Golang 中的包管理机制</p><p>Golang 中的包管理使用 <code>go.mod</code> 文件，可以使用下面的命令在项目根目录初始化一个 <code>go.mod</code>：</p><pre><code class="language-bash"># 初始化一个 v0 或者 v1 的包
$ go mod init example.com/m
# 初始化指定版本的包
$ go mod init example.com/m/v2
</code></pre><p>安装依赖：</p><pre><code class="language-bash">$ go get -u github.com/gin-gonic/gin
</code></pre><blockquote><p><code>-u</code> 安装全局变量类似 <code>npm i -g cobra</code></p></blockquote><p>如果直接下载请求超时，可以设置镜像源：</p><pre><code class="language-bash">$ go env -w GO111MODULE=on
$ go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct
</code></pre><blockquote><p>类似 <code>npm config set registry</code></p></blockquote><p>安装之后就可以看到 <code>go.mod</code> 里面多了些东西：</p><pre><code class="language-go">module github.com/Jiacheng787/goexample

go 1.17

require (
    github.com/gin-gonic/gin v1.7.7
)
</code></pre><p>下载项目依赖：</p><pre><code class="language-bash">$ go get ./...
</code></pre><p><a href="https://zhuanlan.zhihu.com/p/103534192/">三分钟掌握Go mod常用与高级操作</a></p><p>📒 如何解决 CSS 兼容性问题</p><p>对于 JS 的兼容性，我们可以使用 Babel 进行语法转换以及对 API 进行 polyfill。那么对于 CSS 的兼容性如何适配呢？可以使用 PostCSS，最完善的 CSS 工程化解决方案：</p><ul><li><code>autoprefixer</code>：根据 Can I Use 的数据给 CSS 属性添加厂商前缀</li><li><code>postcss-preset-env</code>：允许使用一些提案阶段的特性</li></ul><p>此外还提供各种插件：</p><ul><li><code>postcss-modules</code>：CSS 模块化</li><li><code>postcss-initial</code>：重置默认样式</li><li><code>sugarss</code>：支持缩进语法编写 CSS 样式</li></ul><blockquote><p><a href="https://github.com/postcss/postcss">https://github.com/postcss/postcss</a></p></blockquote><p>📒 <a href="https://www.digitalocean.com/community/tutorials/how-to-process-images-in-node-js-with-sharp#step-3-resizing-changing-image-format-and-compressing-images">How To Process Images in Node.js With Sharp</a></p><p>📒 字节跳动开源项目</p><ul><li><a href="https://github.com/bytedance/IconPark">IconPark - 支持多种主题、跨平台的图标库</a></li><li><a href="https://github.com/bytedance/xgplayer">xgplayer - HTML5 视频播放器</a></li><li><a href="https://github.com/bytedance/sonic">sonic - 基于 JIT 技术的开源全场景高性能 JSON 库</a></li><li><a href="https://github.com/bytedance/bytemd">bytemd - 字节出品的 markdown 编辑器</a></li></ul><p>📒 前端项目 babel 配置</p><p>编译一个前端项目，一般需要安装如下依赖：</p><ul><li><code>@babel/core</code>：核心库</li><li><code>babel-loader</code>：配合 Webpack 打包场景使用</li><li><code>@babel/preset-env</code>：语法转换的预设插件集，同时支持 api 兼容</li><li><code>@babel/preset-react</code>：编译 React 的 JSX 语法</li><li><code>@babel/preset-typescript</code>：可选，编译 TypeScript 语法</li></ul><p>:::tip</p><p><code>@babel/core</code> 是核心库，里面包含：</p><ul><li><code>@babel/parser</code>：一个 ast 解析器，之前叫 Babylon，基于 acorn 魔改而来，负责解析生成 ast</li><li><code>@babel/traverse</code>：负责通过访问者模式遍历并操作 ast 节点</li><li><code>@babel/generator</code>：负责根据 ast 生成代码</li></ul><p><code>babel-loader</code> 用于配合 Webpack 打包场景使用，如果想通过命令行的方式使用，则需要安装 <code>@babel/cli</code></p><p><code>@babel/preset-env</code> 的 api 兼容是通过引入 <code>core-js</code> polyfill 实现的。<code>core-js</code> 引入有多种方式，可以配置 <code>entry</code>，即在入口文件处根据根据 browserslist 配置需要适配的目标环境全量引入 polyfill，也可以配置 <code>usage</code>，根据 browserslist 配置和实际用的 api 按需引入 polyfill。<code>@babel/preset-env</code> 是通过全局污染的形式引入的，一般在前端项目中没问题，但是作为第三方库就不合适了，这时候需要使用 <code>@babel/plugin-transform-runtime</code> 通过沙箱机制引入 polyfill，这种引入方式有个缺点，无法根据 browserslist 配置动态调整引入的 polyfill。</p><p><code>@babel/preset-typescript</code> 实际上就是简单删除掉类型注解。因为 Babel 是单文件处理，不可能进行类型检查，类型检查可以交给 VSCode 插件，或者 <code>ForkTsCheckerWebpackPlugin</code> 单独起一个进程进行类型检查，这时候 tsc 的作用就是类型检查器，需要配置 <code>&quot;noEmit&quot;: true</code>。</p><p>:::</p><p>📒 写文章集合</p><ul><li>Redux 在完善下，增加 UI-binding</li><li>深入源码分析 Koa 中间件与洋葱圈模型</li><li>前端项目的 env 文件是如何被加载的</li><li>Webpack 打包的图片和字体的哈希是如何生成的 - file-loader 源码分析</li></ul>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[1月30日内容汇总]]></title>
        <id>1月30日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/1月30日内容汇总"/>
        <updated>2022-01-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 推荐使用 stylus]]></summary>
        <content type="html"><![CDATA[<p>📒 推荐使用 stylus</p><p>推荐使用 stylus，所有的 <code>{}</code>、<code>:</code> 以及 <code>;</code> 都是可省略的：</p><pre><code class="language-stylus">.page
  padding-bottom 2rem
  display block

.content-lock
  display none
  text-align center
  padding 2rem
  font-size 1em
</code></pre><blockquote><p>这就类似为什么建议使用 <code>yaml</code> 替代 <code>json</code>，在 <code>yaml</code> 中不需要引号，简单省事</p></blockquote><p>📒 页面性能优化技巧</p><p>分析代码执行耗时可以通过 <strong>火焰图</strong>，分析内存占用情况可以通过 <strong>堆快照</strong>。</p><p>⭐️ <a href="https://github.com/streamich/react-use">react-use - 一个 React Hooks 库</a></p><p>📒 Next.js 提供的渲染方式</p><ul><li>SSR: Server-side rendering (服务端渲染)</li><li>SSG: Static-site generation (静态站点生成)</li><li>CSR: Client-side rendering (客户端渲染)</li><li>Dynamic routing (动态路由)</li><li>ISR: Incremental Static Regeneration (增量静态再生)</li></ul><p>:::tip</p><p>CSR、SSR、SSG 的区别？</p><p>CSR 是在用户浏览器端调接口请求数据进行渲染；SSR 是在用户请求页面的时候，服务器端请求数据并进行渲染；SSG 是直接在构建阶段就进行渲染，一般用于文档网站。</p><p>:::</p><p>📒 <a href="https://zhuanlan.zhihu.com/p/461945753">Node 案发现场揭秘 —— 未定义 “window” 对象引发的 SSR 内存泄露</a></p><p>📒 <a href="https://juejin.cn/post/6844903881390964744">从头开始，彻底理解服务端渲染原理(8千字汇总长文)</a></p><p>📒 <a href="https://juejin.cn/post/7039036362653171742">【7000字】一晚上爆肝浏览器从输入到渲染完毕原理</a></p><p>📒 <a href="https://juejin.cn/post/7055101823442485255">爆肝三天，学习Scss-看这篇就够了</a></p><p>⭐️ <a href="https://juejin.cn/post/7057354419888717855">编译技术在前端的实践（二）—— Antlr 及其应用</a></p><p>⭐️ <a href="https://juejin.cn/post/6989509925844041742">编译技术在前端的实践（一）—— 编译原理基础</a></p><p>📒 如何实从零实现 husky</p><p>看下如何做 <strong>测试驱动开发</strong></p><p><a href="https://juejin.cn/post/7057345959402930183">从零实现husky</a></p><p>📒 如何让一个构造函数只能用 <code>new</code> 调用</p><p>使用 ES6 class 会检查是否通过 <code>new</code> 调用，而普通构造函数不会检查是否通过 <code>new</code> 调用，这种情况下需要手动进行判断，通常都会这样做：</p><pre><code class="language-js">function MyClass() {
  if (!(this instanceof MyClass)) {
    throw new Error(&quot;MyClass must call with new&quot;);
  }
  // ...
}
</code></pre><p>这样的话，如果不通过 <code>new</code> 调用，就会抛出异常。其实更好的方案是进行兼容处理，即不使用 <code>new</code> 调用，自动改用 <code>new</code> 调用：</p><pre><code class="language-js">function MyClass() {
  if (!(this instanceof MyClass)) {
    // 如果没有使用 `new` 调用，自动改用 `new` 调用
    // 通过 `return` 中断函数执行，并返回创建的实例
    return new MyClass();
  }
  // ...
}
</code></pre><p>📒 为什么 React Hook 底层使用链表而不是数组</p><p><a href="https://juejin.cn/post/6976903535191392270">React Hooks 核心实现</a></p><p><a href="https://www.yuque.com/liangxinchao/react/qimukg">深入浅出 React</a></p><p><a href="https://react.iamkasong.com/process/fiber-mental.html#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94">React 技术揭秘</a></p><p>📒 React 17 架构</p><p><a href="https://github.com/7kms/react-illustration-series/tree/v17.0.1">图解 React 原理系列</a></p><p><a href="https://react.iamkasong.com/preparation/newConstructure.html">React16架构</a></p><p>📒 数组的 <code>flatMap</code> 方法</p><p>数组的 <code>[].map()</code> 可以实现一对一的映射，映射后的数组长度与原数组相同。有时候需要过滤掉一些元素，或者实现一对多的映射，这时候只用 <code>map</code> 就无法实现了。这种情况下就可以使用 <code>flatMap</code>：</p><pre><code class="language-js">// 需要过滤掉 0，并且使其余各元素的值翻倍
const numbers = [0, 3, 6];

// 常规方法是 map 和 filter 搭配
const doubled = numbers
  .filter(n =&gt; n !== 0)
  .map(n =&gt; n * 2)

// 使用 flatMap 实现
const doubled = numbers.flatMap(number =&gt; {
  return number === 0 ? [] : [2 * number];
})
</code></pre><p>此外还可以实现一对多的映射：</p><pre><code class="language-js">const numbers = [1, 4];
const trippled = numbers.flatMap(number =&gt; {
  return [number, 2 * number, 3 * number];
})
console.log(trippled); // [1, 2, 3, 4, 8, 12]
</code></pre><p>:::tip</p><p><code>flatMap</code> 实际上是先 <code>map</code> 再 <code>flat</code>，理解了这一点就能掌握了</p><p>:::</p><p>📒 <a href="https://blog.appsignal.com/2022/01/19/how-to-set-up-a-nodejs-project-with-typescript.html">如何用 TypeScript 配置一个 Node 项目</a></p><p>📒 <a href="https://remix.run/blog/remix-vs-next">Remix vs Next.js</a></p><p>📒 <a href="https://blog.openreplay.com/3-react-component-design-patterns-you-should-know-about/">你应该知道的三个 React 组件设计模式</a></p><p>📒 <a href="https://juejin.cn/post/7055202073511460895">V8 Promise源码全面解读，其实你对Promise一无所知</a></p><p>⭐️ <a href="https://juejin.cn/post/7036162494573838367">60+ 实用 React 工具库，助力你高效开发！</a></p><p>⭐️ 如何编写更好的 JSX 语句</p><details><summary>查看详情</summary><p>列表不为空的时候进行渲染：</p><pre><code class="language-jsx">// 注意这种写法有 bug
// 如果 data 数组为空，则会直接渲染 `0` 到页面上
{data.length &amp;&amp; &lt;div&gt;{data.map((d) =&gt; d)}&lt;/div&gt;}

// 使用 &amp;&amp; 的时候需要手动转换布尔值
data.length &gt; 0 &amp;&amp; jsx
!!data.length &amp;&amp; jsx
Boolean(data.length) &amp;&amp; jsx
</code></pre><p>不要使用 <code>props</code> 传递的 React 元素作为判断条件:</p><pre><code class="language-jsx">// 这样的判断不准确
// props.children 可能是一个空数组 []
// 使用 children.length 也不严谨，因为 children 也可能是单个元素
// 使用 React.Children.count(props.children) 支持单个和多个 children
// 但是对于存在多个无效节点，例如 false 无法准确判断
// 使用 React.Children.toArray(props.children) 可以删除无效节点
// 但是对于一个空片段，例如 &lt;&gt;&lt;/&gt; 又会被识别为有效的元素
// 所以为了避免出错，建议不要这样判断
const Wrap = (props) =&gt; {
  if (!props.children) return null;
  return &lt;div&gt;{props.children}&lt;/div&gt;
};
</code></pre><p>重新挂载还是更新：</p><pre><code class="language-jsx">// 使用三元运算符分支编写的 JSX 看上去就像完全独立的代码
{hasItem ? &lt;Item id={1} /&gt; : &lt;Item id={2} /&gt;}

// 但实际上 hasItem 切换时，React 仍然会保留挂载的实例，然后更新 props
// 因此上面的代码实际上等价于下面这样
&lt;Item id={hasItem ? 1 : 2} /&gt;

// 一般来讲不会有什么问题，但是对于非受控组件，就可能导致 bug
// 例如 mode 属性变化，会发现之前输入的信息还在
{mode === &#x27;name&#x27;
    ? &lt;input placeholder=&quot;name&quot; /&gt;
    : &lt;input placeholder=&quot;phone&quot; /&gt;}

// 由于 React 会尽可能复用组件实例
// 因此我们可以传递 key，告诉 React 这是两个完全不一样的元素，让 React 强制重新渲染
{mode === &#x27;name&#x27;
    ? &lt;input placeholder=&quot;name&quot; key=&quot;name&quot; /&gt;
    : &lt;input placeholder=&quot;phone&quot; key=&quot;phone&quot; /&gt;}

// 或者使用 &amp;&amp; 替代三元运算符
{mode === &#x27;name&#x27; &amp;&amp; &lt; input  placeholder = &quot;name&quot; /&gt; } 
{mode !== &#x27;name&#x27; &amp;&amp; &lt; input  placeholder = &quot;phone&quot; /&gt; }

// 相反，如果在同一个元素上的逻辑条件不太一样
// 可以试着将条件拆分为两个单独的 JSX 提高可读性
&lt;Button
  aria-busy={loading}
  onClick={loading ? null : submit}
&gt;
  {loading ? &lt;Spinner /&gt; : &#x27;submit&#x27;}
&lt;/Button&gt;

// 可以改为下面这样
{loading
  ? &lt;Button aria-busy&gt;&lt;Spinner /&gt;&lt;/Button&gt;
  : &lt;Button onClick={submit}&gt;submit&lt;/Button&gt;}

// 或者使用 &amp;&amp;
{loading &amp;&amp; &lt;Button key=&quot;submit&quot; aria-busy&gt;&lt;Spinner /&gt;&lt;/Button&gt;}
{!loading &amp;&amp; &lt;Button key=&quot;submit&quot; onClick={submit}&gt;submit&lt;/Button&gt;}
</code></pre><p><a href="https://mp.weixin.qq.com/s/1BX5xK0wpUDBSininJbYHw">写好 JSX 条件语句的几个建议</a></p></details><p>📒 <a href="https://www.youtube.com/watch?v=M3BM9TB-8yA">Node.js 十大设计缺陷 - Ryan Dahl - JSConf EU</a></p><p>📒 <a href="https://juejin.cn/post/7056612950412361741">为什么说 WebAssembly 是 Web 的未来？</a></p><p>📒 <a href="https://juejin.cn/post/7047329886502912030">浅析TypeScript Compiler 原理</a></p><p>📒 <a href="https://juejin.cn/post/7056018952098414605">TypeScript 4.6 beta 发布：递归类型检查增强、参数的控制流分析支持、索引访问的类型推导</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[1月23日内容汇总]]></title>
        <id>1月23日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/1月23日内容汇总"/>
        <updated>2022-01-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 Golang 如何根据指针访问对应的值]]></summary>
        <content type="html"><![CDATA[<p>📒 Golang 如何根据指针访问对应的值</p><p>原始类型需要手动使用 <code>*</code> 操作符，复杂对象会自动解除指针引用：</p><pre><code class="language-go">num := &amp;42
fmt.Println(num) // 打印的是内存地址
fmt.Println(*num) // 42

ms := &amp;myStruct{foo: 42}
(*ms).foo = 17
fmt.Println((*ms).foo) // 17
// 对于复杂对象，直接操作就行
ms.foo = 17
fmt.Println(ms.foo) // 17
</code></pre><p>📒 Golang 创建对象指针的三种方式</p><p>Golang 中所有的赋值操作都是 copy，例如原始类型、<code>array</code>、<code>struct</code>，有两种例外：<code>map</code> 和 <code>slice</code>，它们具有内部指针，在赋值的时候传递指针类型。</p><pre><code class="language-go">// 第一种：对已有的值类型使用 `&amp;` 操作符
ms := myStruct{foo: 42}
p := &amp;ms

// 第二种：在初始化的时候使用 `&amp;` 操作符
p := &amp;myStruct{foo: 42}

// 第三种：使用 `new` 关键字，这种方法不能在初始化的时候进行赋值
var ms *myStruct = new(myStruct)
</code></pre><p>📒 如何渲染虚拟 DOM</p><p>所谓虚拟 DOM 其实就是一棵多叉树，可以使用下面的结构表示：</p><pre><code class="language-ts">class VDOM {
  type: ElementTagName;
  props: ElementProps;
  children: VDOM[];
}
</code></pre><p>渲染虚拟 DOM，很明显要用递归，对不同的类型做不同的处理：</p><ul><li>如果是文本类型，就要用 <code>document.createTextNode</code> 创建文本节点；</li><li>如果是元素类型，就要用 <code>document.createElement</code> 创建元素节点，元素节点还有属性要处理，并且要递归渲染子节点；</li></ul><p>实现 <code>render</code> 函数如下：</p><pre><code class="language-js">const render = (vdom, parent = null) =&gt; {
  const mount = (el) =&gt; {
    if (!parent) return el;
    // 如有父节点则挂载到父节点，组装为 DOM 树
    return parent.appendChild(el);
  }
  if (isTextVdom(vdom)) {
    // 创建文本节点
    return mount(document.createTextNode(vdom));
  } else if (isElementVdom(vdom)) {
    // 创建元素节点
    const dom = mount(document.createElement(vdom.type));
    // 递归渲染子节点，这里使用深度优先遍历
    for (const child of vdom.children) {
      render(child, dom);
    }
    // 给元素添加属性
    for (const prop in vdom.props) {
      setAttribute(dom, prop, vdom.props[prop]);
    }
    return dom;
  }
};
</code></pre><p>如何判断文本节点：</p><pre><code class="language-js">function isTextVdom(vdom) {
  return typeof vdom == &#x27;string&#x27; || typeof vdom == &#x27;number&#x27;;
}
</code></pre><p>如何判断元素节点：</p><pre><code class="language-js">function isElementVdom(vdom) {
  return typeof vdom == &#x27;object&#x27; &amp;&amp; typeof vdom.type == &#x27;string&#x27;;
}
</code></pre><p>如何处理样式、事件、属性：</p><pre><code class="language-js">const setAttribute = (dom, key, value) =&gt; {
  if (typeof value == &#x27;function&#x27; &amp;&amp; key.startsWith(&#x27;on&#x27;)) {
    // 事件处理，使用 `addEventListener` 设置
    const eventType = key.slice(2).toLowerCase();
    dom.addEventListener(eventType, value);
  } else if (key == &#x27;style&#x27; &amp;&amp; typeof value == &#x27;object&#x27;) {
    // 样式处理，合并样式
    Object.assign(dom.style, value);
  } else if (typeof value != &#x27;object&#x27; &amp;&amp; typeof value != &#x27;function&#x27;) {
    // 属性处理，使用 `setAttribute` 设置
    dom.setAttribute(key, value);
  }
}
</code></pre><p>📒 <a href="https://juejin.cn/post/7054034318594850823">能用js实现的最终用js实现，Shell脚本也不例外</a></p><p>📒 <a href="https://github.com/luciopaiva/heapify">heapify：最快的 JavaScript 优先级队列库</a></p><p>📒 <a href="https://github.com/mailru/easyjson">easyjson：Golang 中的序列化库，比 <code>encoding/json</code> 快 4-5 倍</a></p><p>📒 <a href="https://github.com/fastify/fast-json-stringify">fast-json-stringify：比 <code>JSON.stringify</code> 快两倍</a></p><p>📒 <a href="https://juejin.cn/post/7048970987500470279">六千字详解！vue3 响应式是如何实现的？</a></p><p>📒 Nodejs 如何将图片转为 base64</p><p>使用 Buffer 对象：</p><pre><code class="language-js">import fs from &quot;node:fs&quot;;
import path from &quot;node:path&quot;;

const raw = fs.readFileSync(path.join(__dirname, &#x27;./2333.png&#x27;), &#x27;binary&#x27;);
const buf = Buffer.from(raw, &#x27;binary&#x27;);
const string = buf.toString(&#x27;base64&#x27;);
</code></pre><p>同理可以将 base64 转回图片：</p><pre><code class="language-js">const raw =  Buffer.from(string, &#x27;base64&#x27;).toString(&#x27;binary&#x27;);
</code></pre><p>📒 Nodejs 如何实现图片处理</p><p>推荐使用 <code>sharp</code> 这个库，可以实现图片压缩，转 JPEG、PNG、WebP 等格式：</p><blockquote><p><a href="https://github.com/lovell/sharp">https://github.com/lovell/sharp</a></p></blockquote><p>📒 如何打印 26 个字母的字符串</p><p>一行代码搞定：</p><pre><code class="language-js">String.fromCharCode(...Array.from({ length: 26 }, (_, index) =&gt; 97 + index));
// &#x27;abcdefghijklmnopqrstuvwxyz&#x27;
</code></pre><p>📒 如何用 Map 实现 Set</p><p>关于 Map 和 Set 是两个抽象数据结构，Map 存储一个键值对集合，其中键不重复，Set 存储一个不重复的元素集合。本质上 Set 可以视为一种特殊的 Map，Set 其实就是 Map 中的键：</p><pre><code class="language-ts">class NewSet&lt;T extends unknown&gt; {
  private collection: Map&lt;T, undefined&gt;;
  
  constructor(iterable: T[] = []) {
    this.collection = new Map(
      iterable.map(it =&gt; [it, undefined])
    );
  }
}
</code></pre><p>📒 方法重载与参数默认值</p><p>为了支持可变参数，在 Java 中通过 <strong>方法重载</strong> 实现，通过定义多个方法签名，根据实际调用传递的参数去匹配签名。在 TypeScript 中也提供了方法重载特性，但在开发中很少用到，一般都通过 <strong>参数默认值</strong> 实现可变参数：</p><pre><code class="language-ts">type NewSet&lt;T&gt; = (iterable: T[] = []) =&gt; void
</code></pre><blockquote><p>注意使用参数默认值之后，TS 会自动将这个参数推导为可变参数，例如上面这个会推导为 <code>NewSet&lt;T&gt;(iterable?: T[]): void</code></p></blockquote><p>📒 项目常用工具库</p><ul><li><code>dayjs</code>：与 <code>moment</code> 的 API 设计保持一样，但体积仅有 2KB；</li><li><code>qs</code>：解析 URL query 参数的库；</li><li><code>js-cookie</code>：简单、轻量的处理 cookie 的库；</li><li><code>flv.js</code>：bilibili 开源的 HTML5 flash 播放器，使浏览器在不借助 flash 插件的情况下可以播放 flv；</li><li><code>vConsole</code>：一个轻量、可拓展、针对手机网页的前端开发者调试面板；</li><li><code>animate.css</code>：一个跨浏览器的 css3 动画库，内置了很多典型的 css3 动画，兼容性好，使用方便；</li><li><code>lodash</code>：一个一致性、模块化、高性能的 JavaScript 实用工具库；</li></ul><p>⭐️ <a href="https://github.com/ngneat/elf">elf: 使用 RxJs 的响应式状态管理</a></p><p>📒 如何防止 CSS 样式污染</p><ul><li>使用命名约定</li><li>CSS Modules</li><li>CSS in JS</li></ul><p>其中命名约定最流行的方式是 BEM 101。它代表了 <code>Block</code>、<code>Element</code>、<code>Modifier</code> 方法。</p><pre><code class="language-css">[block]__[element]--[modifier]
/* Example */
.menu__link--blue {
  ...
}
</code></pre><p>📒 <a href="https://juejin.cn/post/7040849488998563848">现代配置指南——YAML 比 JSON 高级在哪？</a></p><p>📒 <a href="https://juejin.cn/post/7029512357428592648">前端架构师神技，三招统一团队代码风格</a></p><p>📒 <a href="https://juejin.cn/post/7024043015794589727">前端架构师的 git 功力，你有几成火候？</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[1月16日内容汇总]]></title>
        <id>1月16日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/1月16日内容汇总"/>
        <updated>2022-01-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 实现一个 WebAssembily 版本的 Python 解释器]]></summary>
        <content type="html"><![CDATA[<p>📒 实现一个 WebAssembily 版本的 Python 解释器</p><ul><li>wasm 可以把代码编译出来，但是能否执行</li><li>如果 Python 代码涉及系统调用，例如代码中经常需要进行文件 IO，这种情况下 wasm 能否实现</li></ul><blockquote><p><a href="https://github.com/pyodide/pyodide">https://github.com/pyodide/pyodide</a></p></blockquote><p>📒 Webpack5 配置了 <code>devServer.hot = true</code> 是否会自动配置 <code>HotModuleReplacementPlugin</code></p><p>📒 看下 axios 源码，响应拦截中第一个回调 <code>reject</code> 能否进入第二个回调</p><p>📒 webpack-dev-server 如何配置代理</p><details><summary>查看详情</summary><p>在 CRA 搭建的项目中，我们知道可以在 <code>src/setupProxy.js</code> 文件中写入代理配置：</p><pre><code class="language-js">const proxy = require(&#x27;http-proxy-middleware&#x27;);

module.exports = function(app) {
  app.use(
    proxy(
      &#x27;/course&#x27;,
      {
        target: &#x27;https://ke.study.163.com&#x27;,
        changeOrigin: true,
      },
    ),
  )
}
</code></pre><p>那么手动搭建的项目该如何配置代理呢？我们看一下 CRA 源码：</p><pre><code class="language-js">// react-scripts/config/paths.js:87

module.exports = {
  // ...
  proxySetup: resolveApp(&#x27;src/setupProxy.js&#x27;),
  // ...
}
</code></pre><p>然后去找哪里用到了 <code>proxySetup</code> ：</p><pre><code class="language-js">// react-scripts/config/webpackDevServer.config.js:112

onBeforeSetupMiddleware(devServer) {
  // Keep `evalSourceMapMiddleware`
  // middlewares before `redirectServedPath` otherwise will not have any effect
  // This lets us fetch source contents from webpack for the error overlay
  devServer.app.use(evalSourceMapMiddleware(devServer));

  if (fs.existsSync(paths.proxySetup)) {
    // This registers user provided middleware for proxy reasons
    require(paths.proxySetup)(devServer.app);
  }
},
</code></pre><p>看了下上面的配置，说明应该是这么用的：</p><pre><code class="language-js">const compiler = webpack(config);
const devServer = new WebpackDevServer(options, compiler);

devServer.app.use(
  proxy(
    &#x27;/course&#x27;,
    {
      target: &#x27;https://ke.study.163.com&#x27;,
      changeOrigin: true,
    },
  ),
)
</code></pre></details><p>📒 <a href="https://juejin.cn/post/7051535411042058271">不优雅的 React Hooks</a></p><p>📒 为什么可以用函数模拟一个模块</p><p>在一个模块中，有一些属性和方法是私有的，另外一些是对外暴露的：</p><pre><code class="language-js">// main.js
let foo = 1;
let bar = 2;

export const getFoo = () =&gt; foo;
export const getBar = () =&gt; bar;
const defaultExport = () =&gt; foo + bar;
export default defaultExport;

// index.js
import main, { getFoo, getBar } from &quot;./main&quot;;
</code></pre><p>这种行为就可以通过函数模拟出来，其中私有变量、方法以闭包的形式实现，这样只有模块内部才能访问：</p><pre><code class="language-js">const main = (function() {
  let foo = 1;
  let bar = 2;
  const getFoo = () =&gt; foo;
  const getBar = () =&gt; bar;
  const defaultExport = () =&gt; foo + bar;

  return {
    getFoo,
    getBar,
    default: defaultExport
  }
})();
</code></pre><p>:::tip</p><p>可以看到给默认导出加了一个 <code>deafult</code> 属性。</p><p>:::</p><p>另外推荐看看 <code>browserify</code> 这个库，如何在浏览器端实现 CommonJS 模块机制：</p><blockquote><p><a href="https://browserify.org/">https://browserify.org/</a></p></blockquote><p>📒 Webpack 中 loader 处理流程</p><p>有点像责任链模式，上一个函数的返回值会作为参数传入下一个函数。需要注意使用 <code>call</code> 方法让每个 loader 内部可以获取到 loaderAPI：</p><pre><code class="language-js">import { readFileSync } from &#x27;node:fs&#x27;;

const loaders = [];
const raw = readFileSync(&#x27;xxx&#x27;);

const loaderAPI = {
  emitFile: () =&gt; {},
}

const parsed = loaders.reduce(
  (accu, cur) =&gt; cur.call(loaderAPI, accu),
  raw
);
</code></pre><p>📒 字体文件的 hash 是如何生成的，<code>file-loader</code> 中如何处理的</p><p>写一篇文章：《你不知道的 Webpack loader —— file-loader 源码探秘》</p><p><a href="https://www.cnblogs.com/shiyunfront/articles/8944940.html">webpack 源码解析:file-loader 和 url-loader</a></p><p><a href="https://github.com/webpack-contrib/file-loader/blob/master/src/index.js">file-loader - GitHub</a></p><p><a href="https://github.com/webpack/loader-utils/blob/master/lib/interpolateName.js">loader-utils - GitHub</a></p><p>📒 Golang 编译为 WebAssembly</p><p>在 Golang 中可以使用 <code>syscall/js</code> 这个库与 JS 环境进行交互，可以调用 JS 的 API，以及传递 JSON 数据：</p><pre><code class="language-go">package main
 
import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;syscall/js&quot;
)
 
type Person struct {
    Name string `json:&quot;name&quot;`
    Age  int    `json:&quot;age&quot;`
}

func main() {
  // Work around for passing structs to JS
  frank := &amp;Person{Name: &quot;Frank&quot;, Age: 28}
  p, err := json.Marshal(frank)
  if err != nil {
      fmt.Println(err)
      return
  }
  obj := js.Global().Get(&quot;JSON&quot;).Call(&quot;parse&quot;, string(p))
  js.Global().Set(&quot;aObject&quot;, obj)
}
</code></pre><p><a href="https://www.sitepen.com/blog/compiling-go-to-webassembly">Compiling Go to WebAssembly</a></p><p>📒 Golang 中的指针</p><p>对于原始类型来说，赋值就等于 copy，相当于在内存中创建一个一模一样的值，具有不同的内存地址：</p><pre><code class="language-go" metastring="{3}">func main() {
  a := 42
  b := a
  fmt.Println(a, b) // 42 42
  a = 27
  fmt.Println(a, b) // 27 42
}
</code></pre><p>可以通过 <code>&amp;</code> 操作符取到内存地址：</p><pre><code class="language-go" metastring="{3}">func main() {
  var a int = 42
  var b *int = &amp;a
  fmt.Println(a, b) // 42 0×1040a124
}
</code></pre><p>还可以通过 <code>*</code> 操作符根据内存地址访问对应的值：</p><pre><code class="language-go" metastring="{4}">func main() {
  var a int = 42
  var b *int = &amp;a
  fmt.Println(a, *b) // 42 42
}
</code></pre><p>由于 <code>b</code> 实际持有的是 <code>a</code> 的指针引用，因此修改 <code>a</code> 会导致 <code>b</code> 指向的值发生变化：</p><pre><code class="language-go" metastring="{5,7}">func main() {
  var a int = 42
  var b *int = &amp;a
  fmt.Println(a, *b) // 42 42
  a = 27
  fmt.Println(a, *b) // 27 27
  *b = 14
  fmt.Println(a, *b) // 14 14
}
</code></pre><p>📒 Golang 中的 <code>struct</code></p><p>注意 <code>struct</code> 与 <code>slice</code>、<code>map</code> 不同，下面这个操作实际上是完整 copy 了一个对象，内存开销较大：</p><pre><code class="language-go" metastring="{15}">package main

import (
  &quot;fmt&quot;
)

type Doctor struct {
  name string
}

func main() {
  aDoctor := Doctor{
    name: &quot;John Pertwee&quot;
  }
  anotherDoctor := aDoctor
  anotherDoctor.name = &quot;Tom Baker&quot;
  fmt.Println(aDoctor) // {John Pertwee}
  fmt.Println(anotherDoctor) // {Tom Baker}
}
</code></pre><p>可以使用 <code>&amp;</code> 操作符拿到对象的指针进行赋值，这时候两边就是联动的：</p><pre><code class="language-go" metastring="{5}">func main() {
  aDoctor := Doctor{
    name: &quot;John Pertwee&quot;
  }
  anotherDoctor := &amp;aDoctor
  anotherDoctor.name = &quot;Tom Baker&quot;
  fmt.Println(aDoctor) // {Tom Baker}
  fmt.Println(anotherDoctor) // &amp;{Tom Baker}
}
</code></pre><p>注意 <code>array</code> 进行赋值也会 copy：</p><pre><code class="language-go" metastring="{2}">func main() {
  a := [3]int{1, 2, 3}
  b := a
  fmt.Println(a, b) // [1, 2, 3] [1, 2, 3]
  a[1] = 42
  fmt.Println(a, b) // [1, 42, 3] [1, 2, 3]
}
</code></pre><p>但如果将 <code>array</code> 改为 <code>slice</code>，赋值传递的就是指针：</p><pre><code class="language-go" metastring="{2}">func main() {
  a := []int{1, 2, 3}
  b := a
  fmt.Println(a, b) // [1, 2, 3] [1, 2, 3]
  a[1] = 42
  fmt.Println(a, b) // [1, 2, 3] [1, 2, 3]
}
</code></pre><p>📒 <a href="https://juejin.cn/post/7051929587852247077">年终盘点：2022基于Monorepo的首个大趋势-TurboRepo</a></p><p>⭐️ <a href="https://juejin.cn/post/7034419410706104356">2022年如何成为一名优秀的大前端Leader？</a></p><p>📒 GitHub 定时任务</p><p>下面的代码中，<code>on</code> 字段指定了两种触发条件，一个是代码 <code>push</code> 进仓库，另一种是定时任务，每天在国际标准时间21点（北京时间早上5点）运行。</p><pre><code class="language-yaml">on:
  push:
  schedule:
    - cron: &#x27;0 21 * * *&#x27;
</code></pre><p>定时任务配置参考：</p><blockquote><p><a href="https://github.com/lxchuan12/juejin-actions">https://github.com/lxchuan12/juejin-actions</a></p></blockquote><p>另外推荐一个项目，可以使用 <code>curl wttr.in</code> 命令获取天气预报：</p><blockquote><p><a href="https://github.com/chubin/wttr.in">https://github.com/chubin/wttr.in</a></p></blockquote><p>📒 如何开发一个 CLI 工具</p><p>参考下尤大的项目：</p><pre><code class="language-js">const templateDir = path.join(__dirname, `template-${template}`)

const write = (file, content) =&gt; {
  const targetPath = renameFiles[file]
    ? path.join(root, renameFiles[file])
    : path.join(root, file)
  if (content) {
    fs.writeFileSync(targetPath, content)
  } else {
    copy(path.join(templateDir, file), targetPath)
  }
}

const files = fs.readdirSync(templateDir)
for (const file of files.filter((f) =&gt; f !== &#x27;package.json&#x27;)) {
  write(file)
}
</code></pre><p>注意这里有两个文件要处理下，一个是给 <code>package.json</code> 修改包名：</p><pre><code class="language-js">const pkg = require(path.join(templateDir, `package.json`))

pkg.name = packageName || targetDir

write(&#x27;package.json&#x27;, JSON.stringify(pkg, null, 2))
</code></pre><p>还有是 <code>.gitignore</code> 修改文件名：</p><pre><code class="language-js">const renameFiles = {
  _gitignore: &#x27;.gitignore&#x27;
}
</code></pre><blockquote><p><a href="https://github.com/vitejs/vite/blob/main/packages/create-vite/index.js">https://github.com/vitejs/vite/blob/main/packages/create-vite/index.js</a></p></blockquote><p>📒 命令行工具开发技术栈</p><ul><li><code>chalk/kolorist</code></li><li><code>inquirer/prompts</code></li><li><code>ora</code></li><li><code>semver</code></li><li><code>pkg-install</code></li><li><code>ncp</code></li><li><code>commander/yargs</code></li><li><code>execa</code>（个人觉得 Node 原生 <code>child_process</code> 的 <code>exec</code> 就够用了）</li><li><code>minimist</code></li></ul><p>:::tip</p><p>网上一些文章也都实现了递归拷贝文件，但是是否考虑到了跨平台，可以看下 <code>ncp</code> 的实现</p><p><a href="https://github.com/AvianFlu/ncp">https://github.com/AvianFlu/ncp</a></p><p>Node.js 原生的 <code>child_process.exec</code> 也可以执行命令，看下 <code>execa</code> 是如何支持 Promise 的</p><p><a href="https://github.com/sindresorhus/execa">https://github.com/sindresorhus/execa</a></p><p>:::</p><p>现在开发已经不需要自己组装 pick 了，<code>common-bin</code>、<code>oclif</code> 这两个，约定式路由。</p><p>另外脚手架工具，可以看看 <code>plop</code>和 <code>yeoman</code>，一个是基于 <code>action</code> 和 <code>inquirer</code> 的生态，一个是内核加自定义模板项目。</p><p>其实最简单的脚手架，不是通过cli界面选择模板，然后到 github 上去下载对应的模板文件，而是 <code>start-kit</code> 。</p><blockquote><p><a href="https://github.com/digipolisantwerp/starter-kit-ui_app_nodejs">https://github.com/digipolisantwerp/starter-kit-ui_app_nodejs</a></p></blockquote><p>📒 <a href="https://juejin.cn/post/7051355444341637128">「前端基建」探索不同项目场景下Babel最佳实践方案</a></p><p>📒 <a href="https://juejin.cn/post/7051236803344334862">说不清rollup能输出哪6种格式😥差点被鄙视</a></p><p>📒 <a href="https://juejin.cn/post/7035448197883363359">【手把手】学会VS Code&quot;任务&quot;神技，成为项目组最靓的崽！</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[1月9日内容汇总]]></title>
        <id>1月9日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/1月9日内容汇总"/>
        <updated>2022-01-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 Golang 模拟 JS 的 Promise]]></summary>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[1月2日内容汇总]]></title>
        <id>1月2日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/1月2日内容汇总"/>
        <updated>2022-01-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 clsx：classnames 的替代方案]]></summary>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[12月26日内容汇总]]></title>
        <id>12月26日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/12月26日内容汇总"/>
        <updated>2021-12-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 腾讯技术工程相关文章]]></summary>
        <content type="html"><![CDATA[<p>📒 腾讯技术工程相关文章</p><ul><li><a href="https://zhuanlan.zhihu.com/p/334617737">14W 行代码量的前端页面长什么样</a></li><li><a href="https://zhuanlan.zhihu.com/p/90836859">万字长文轻松彻底入门 Flutter，秒变大前端</a></li><li><a href="https://zhuanlan.zhihu.com/p/444802648">Git 分支操作&amp;存储原理浅谈</a></li><li><a href="https://zhuanlan.zhihu.com/p/405387352">QUIC 协议详解</a></li></ul><p>⭐️ <a href="https://zhuanlan.zhihu.com/p/340814811">收藏 | 腾讯技术 2020 年精华文章合集</a></p><p>🐛 生产环境如何 debug</p><ul><li>定位错误是前端还是后端接口返回的<ul><li>前端代码全局搜索关键字（vscode 或者 chorme devtools 中搜索）</li><li>翻阅 network 面板中的请求，使用 <code>⌘ + F</code> 打开 network search 面板进行搜索</li></ul></li><li>如何调试混淆压缩后的 JS<ul><li>使用 source 面板中的 pretty-print 选项</li><li>这样还是存在问题，例如很多变量名、方法名都被混淆压缩了，然后 babel 会将 ES2015+ 语法进行语法转换，代码可读性降低</li></ul></li><li>如何在生产环境中使用 sourceMap 调试<ul><li>打开混淆压缩的代码，右键选择 Add source map</li><li>这里需要添加一个 source map URL，可以将本地项目添加到 source 面板中的 Filesystem 中，或者启用静态资源服务</li><li>添加之后就可以直接搜索项目中的源文件了</li></ul></li><li>如何在 chrome 中修改代码并调试<ul><li>chrome devtools 提供了 local overrides 能力，指定修改后的文件的本地保存目录，当修改完代码保存的时候，就会将修改后的文件保存到你指定的目录目录下，当再次加载页面的时候，对应的文件不再读取网络上的文件，而是读取存储在本地修改过的文件</li><li>打开 sources 下的 overrides 面板，点击 select folder overrides 选择修改后的文件件存储地址，我们就可以打开文件修改，修改完成后保存，重新刷新页面后，修改后的代码就被执行到了</li></ul></li></ul><blockquote><p><a href="https://juejin.cn/post/7044678301926817806">前端工程师生产环境 debugger 技巧</a></p></blockquote><p>📒 如何在 React 中优雅使用 ECharts</p><p>初始化 ECharts 的时候不要使用 id，否则无法渲染多个组件实例：</p><pre><code class="language-jsx" metastring="{5,8,15}">import * as React from &quot;react&quot;;
import * as echarts from &quot;echarts&quot;;

const LineChart = (props) =&gt; {
  const chartRef = React.useRef();

  React.useEffect(() =&gt; {
    const chart = echarts.init(chartRef.current);
    const option = {
      // ...
    }
    chart.setOptions(option);
  }, [props])
  
  return &lt;div ref={chartRef} className=&quot;chart&quot;&gt;&lt;/div&gt;
}

export default React.memo(LineChart);
</code></pre><p>如何让 ECharts 实现自适应，可以在窗口尺寸变化的时候，调用 chart 实例上的 <code>resize</code> 方法：</p><pre><code class="language-jsx" metastring="{8-10,13,17}">React.useEffect(() =&gt; {
  const chart = echarts.init(chartRef.current);
  const option = {
    // ...
  }
  chart.setOptions(option);

  const handleResize = () =&gt; {
    chart.resize();
  }

  // 绑定 resize 事件监听器
  window.addEventListener(&quot;resize&quot;, handleResize);

  return () =&gt; {
    // 组件更新或者卸载时移除监听
    window.removeEventListener(&quot;resize&quot;, handleResize);
  }
}, [props])
</code></pre><blockquote><p>推荐使用 <code>addEventListener</code> 绑定事件，可以多次绑定，但是要注意及时 remove，不然会导致内存泄漏</p></blockquote><p>📒 看火焰图分析调用栈的时候，看到一个 <code>asyncGeneratorStep</code> 的函数，一直没搞清楚这个在哪里用到了</p><p><img src="./POPO20211223-201441.png" alt="image"/></p><p>事后才想到这是 babel 语法转换引入的 helper 函数</p><p><img src="./POPO20211223-113701.png" alt="image"/></p><p>📒 使用 webpack-chain 对 vue-cli 默认配置进行修改</p><blockquote><p><a href="https://github.com/Yatoo2018/webpack-chain/tree/zh-cmn-Hans">https://github.com/Yatoo2018/webpack-chain/tree/zh-cmn-Hans</a></p></blockquote><p>📒 如何对 webpack 打包产物进行分析</p><p>经常需要分析打包产物的体积，看哪个包体积过大，做针对性优化。可以使用 Webpack Bundle Analyzer：</p><pre><code class="language-bash">$ yarn add webpack-bundle-analyzer -D
</code></pre><p>在 <code>webpack.config.js</code> 中添加如下配置：</p><pre><code class="language-js">const { BundleAnalyzerPlugin } = require(&#x27;webpack-bundle-analyzer&#x27;);

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
</code></pre><p>然后执行打包构建命令：</p><pre><code class="language-bash">$ yarn build --report
</code></pre><blockquote><p><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">https://github.com/webpack-contrib/webpack-bundle-analyzer</a></p></blockquote><p>📒 create-react-app 发布 5.0 版本</p><p>本次的 5.0 版本优化了快速刷新(Fast Refresh)，支持了 Tailwind，并更新了不少内部依赖库，如 Webpack 5、Jest 27 和 EsLint 8 等。</p><blockquote><p><a href="https://github.com/facebook/create-react-app/releases/tag/v5.0.0">https://github.com/facebook/create-react-app/releases/tag/v5.0.0</a></p></blockquote><p>📒 处理你应用中的内存泄漏</p><p>作者 Stoyan 提到：“任何大小合理的应用中，都会存在一定程度的内存泄漏”。因此知道如何处理泄漏是一件很有用的事。在本文中，作者举了一个 React 中的例子，不过它的基本理念却可以运用在任何地方。</p><blockquote><p><a href="https://calendar.perfplanet.com/2021/plugging-memory-leaks-in-your-app/">https://calendar.perfplanet.com/2021/plugging-memory-leaks-in-your-app/</a></p></blockquote><p>📒 kalidokit：人体动作表情解读同步</p><p>效果还是和牛逼的，真人测试。</p><blockquote><p><a href="https://github.com/yeemachine/kalidokit">https://github.com/yeemachine/kalidokit</a></p></blockquote><p>📒 xterm：把命令行搬到浏览器</p><blockquote><p><a href="https://xtermjs.org/">https://xtermjs.org/</a></p></blockquote><p>📒 microdiff：轻量快速的对比库</p><blockquote><p><a href="https://github.com/AsyncBanana/microdiff">https://github.com/AsyncBanana/microdiff</a></p></blockquote>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[12月19日内容汇总]]></title>
        <id>12月19日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/12月19日内容汇总"/>
        <updated>2021-12-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[⭐️ Webpack 分包最佳实践]]></summary>
        <content type="html"><![CDATA[<p>⭐️ Webpack 分包最佳实践</p><p>SplitChunksPlugin 进行分包的三要素:</p><ol><li><code>minChunks</code>: 一个模块是否最少被 minChunks 个 chunk 所引用</li><li><code>maxInitialRequests/maxAsyncRequests</code>: 最多只能有 maxInitialRequests/maxAsyncRequests 个 chunk 需要同时加载 (如一个 Chunk 依赖 VendorChunk 才可正常工作，此时同时加载 chunk 数为 2)</li><li><code>minSize/maxSize</code>: chunk 的体积必须介于 (minSize, maxSize) 之间</li></ol><p>哪些应该单独分包：</p><ol><li>Webpack 运行时</li><li>React Framework 运行时，包括 React/React-DOM 及它们所有的依赖</li><li>大型库，体积特别大的库</li><li>公共库，至少被 4 个 Chunk 所引用的公共模块</li></ol><p>:::tip</p><p>Webpack 配置最佳实践，除了 Vue-cli 和 CRA 源码，还可以参考 <code>next.js</code> 源码：</p><p><a href="https://github.com/vercel/next.js/blob/canary/packages/next/build/webpack-config.ts">https://github.com/vercel/next.js/blob/canary/packages/next/build/webpack-config.ts</a></p><p>:::</p><p><a href="https://mp.weixin.qq.com/s/LrASIdA19iwIwng29G5HpA">Webpack 性能系列四：分包优化</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/AxwT588VKRxnlkBlXICMpQ">【内部分享】看向未来 - 近期 TC39 提案汇总</a></p><p>📒 如何移除代码中的 <code>console</code></p><ol><li><p>使用 <code>uglifyjs-webpack-plugin</code> 或 <code>terser-webpack-plugin</code> 中的 <code>drop_console</code> 配置；</p></li><li><p>使用 Babel 插件 <code>babel-plugin-transform-remove-console</code>；</p></li><li><p>简单粗暴删除，直接重写 <code>console.log</code> 方法；</p><pre><code class="language-js">console.log = function() {};
</code></pre></li><li><p>手写 webpack loader 删除；</p><pre><code class="language-js">// clearConsole.js
const reg = /(console.log\()(.*)(\))/g;
module.exports = function(source) {
    source = source.replace(reg, &quot;&quot;)
    return source;
}
</code></pre><blockquote><p>基于正则匹配还是有一些问题，例如 <code>const { log } = console</code> 或者 <code>const log = console.log.bind(console)</code> 这种就匹配不到</p></blockquote></li></ol><p>📒 WebRTC 录屏技术</p><p>WebRTC 是一套基于音视轨的实时数据流传播的技术方案。通过浏览器原生 API <code>navigator.mediaDevices.getDisplayMedia</code> 方法实现提示用户选择和授权捕获展示的窗口，进而获取 stream (录制的屏幕音视流)。我们可以对 stream 进行转化处理，转成相对应的媒体数据，并将其数据存储。</p><pre><code class="language-js">var promise = navigator.mediaDevices.getDisplayMedia(constraints);
</code></pre><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia">https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia</a></p></blockquote><ul><li><a href="https://juejin.cn/post/7028723258019020836">浅析Web录屏技术方案与实现</a></li><li><a href="https://juejin.cn/post/6896045087659130894">从0到1打造一个 WebRTC 应用</a></li><li><a href="https://juejin.cn/post/7010954456548245541">浅聊WebRTC视频通话</a></li></ul><p>📒 Go 1.18 Beta 1 已经正支持泛型</p><ul><li><a href="https://go.dev/blog/go1.18beta1">Go 1.18 Beta 1 is available, with generics</a></li><li><a href="https://go.dev/blog/why-generics">Why Generics?</a></li><li><a href="https://go.dev/play/?v=gotip">The Go Playground</a></li></ul><p>📒 <a href="https://juejin.cn/post/7041846339189080101">使用Golang、Gin和React、esbuild开发的Blog</a></p><p>📒 使用 patch-package 修复 npm 库的紧急问题</p><p>如果使用的 npm 库有 bug，可以使用 patch-package 创建一个补丁包。</p><p><a href="https://juejin.cn/post/7029310620952428558">工程化知识卡片 022: 质量保障篇之如何优雅某个 npm 库的紧急问题</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/WWQa4kJXAblBkZS5zx3HBw">5 种有趣的 useEffect 无限循环类型</a></p><p>📒 <a href="https://github.com/you-dont-need/You-Dont-Need-JavaScript">用 CSS 来代替 JS 的实现</a></p><p>📒 <a href="https://juejin.cn/post/7027995169211285512">React18 新特性：transition</a></p><p>📒 <a href="https://juejin.cn/post/7038370502926139399">「2021」我给Vue.js生态贡献代码的这一年</a></p><p>⭐️ ⭐️ fiber：受到 Express 启发的 Web 应用框架，使用 Go 开发，与 Express 的 API 非常接近</p><pre><code class="language-go">package main

import &quot;github.com/gofiber/fiber/v2&quot;

func main() {
  app := fiber.New()

  app.Get(&quot;/&quot;, func(c *fiber.Ctx) error {
    return c.SendString(&quot;Hello, World 👋!&quot;)
  })

  app.Listen(&quot;:3000&quot;)
}
</code></pre><blockquote><p><a href="https://github.com/gofiber/fiber">https://github.com/gofiber/fiber</a></p></blockquote>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[12月12日内容汇总]]></title>
        <id>12月12日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/12月12日内容汇总"/>
        <updated>2021-12-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 优雅获取 package.json 文件]]></summary>
        <content type="html"><![CDATA[<p>📒 优雅获取 <code>package.json</code> 文件</p><p>这里需要注意一个问题，在 ES module 规范下无法直接引入 JSON 文件，只能通过 <code>require</code> 获取：</p><pre><code class="language-javascript">// ES module 模块
import React from &quot;react&quot;;
import { debounce } from &quot;lodash-es&quot;;
// JSON 模块只能通过 CJS 方式加载
const package = require(&quot;package.json&quot;);
</code></pre><p><code>import</code> 命令目前只能用于加载 ES 模块，现在有一个提案，允许加载 JSON 模块。<code>import</code> 命令能够直接加载 JSON 模块以后，就可以像下面这样写:</p><pre><code class="language-javascript">import configData from &#x27;./config.json&#x27; assert { type: &quot;json&quot; };
console.log(configData.appName);
</code></pre><blockquote><p><code>import</code> 命令导入 JSON 模块时，命令结尾的 <code>assert {type: &quot;json&quot;}</code> 不可缺少。这叫做导入断言，用来告诉 JavaScript 引擎，现在加载的是 JSON 模块</p></blockquote><p>除此之外，还可以使用第三方库 <code>read-pkg</code> 获取，原理是通过 <code>fs</code> 模块读取 <code>package.json</code> 文件，然后反序列化为 JS 对象：</p><pre><code class="language-javascript">import process from &#x27;node:process&#x27;;
import fs, {promises as fsPromises} from &#x27;node:fs&#x27;;
import path from &#x27;node:path&#x27;;
import parseJson from &#x27;parse-json&#x27;;
import normalizePackageData from &#x27;normalize-package-data&#x27;;

export async function readPackage({cwd = process.cwd(), normalize = true} = {}) {
    const filePath = path.resolve(cwd, &#x27;package.json&#x27;);
    const json = parseJson(await fsPromises.readFile(filePath, &#x27;utf8&#x27;));

    if (normalize) {
        normalizePackageData(json);
    }

    return json;
}
</code></pre><p>📒 如何覆盖某些元素的浏览器默认样式</p><p>很多元素，例如 <code>&lt;button&gt;</code>、<code>&lt;input type=&quot;text&quot; /&gt;</code>、<code>&lt;input type=&quot;checkbox&quot; /&gt;</code> 具有浏览器默认样式，有时候需要自己指定样式，如何覆盖浏览器默认样式，只需要下面一行代码：</p><pre><code class="language-css">input {
    -webkit-appearance: none;
}
</code></pre><p>📒 如何让 div 按比例缩放</p><p>有时希望 div 自适应页面宽度的时候，可以按比例缩放，这种情况下可以使用 <code>aspect-ratio</code> 属性：</p><pre><code class="language-css">div {
    aspect-ratio: auto 1 / 1;
}
</code></pre><p>推荐在 <code>ratio</code> 前面加 <code>auto</code> ，对于 input 等具有固有宽高比的替换元素将使用默认宽高比，否则就使用指定的宽高比。</p><blockquote><p>注意 <code>aspect-ratio</code> 兼容 Chrome &gt; 87 ，所有的 IE 浏览器都不兼容</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/aspect-ratio">aspect-ratio - MDN</a></p><p>📒 <a href="https://www.smashingmagazine.com/2021/11/maintain-large-nextjs-application/">如何维护一个大型的 Next.js 应用</a></p><p>📒 Goober：CSS-in-JS 方案</p><p>这是一个 1 KB 大小的 CSS-in-JS 方案，可以替代 23 KB 的 styled-components 和 emotion 组合。而且如果你可以减少 goober 库 gzip 后的体积，他们还会奖励你美元。</p><blockquote><p><a href="https://github.com/cristianbote/goober">https://github.com/cristianbote/goober</a></p></blockquote><p>📒 使用支持 Tree Shaking 的包</p><p>如果可以的话，应尽量使用支持 Tree Shaking 的 npm 包，例如：</p><ul><li>使用 <code>lodash-es</code> 替代 <code>lodash</code> ，或者使用 <code>babel-plugin-lodash</code> 实现类似效果</li></ul><p>📒 win10 安装 nvm-windows</p><p>下载地址：</p><blockquote><p><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p></blockquote><p>用法跟 mac 上的 nvm 类似：</p><pre><code class="language-bash"># 安装 nodejs v16.13.1
$ nvm install 16.13.1

# 查看已安装的 nodejs 版本
$ nvm list

# 使用指定版本的 nodejs
$ nvm use 16.13.1

# 卸载某个版本的 nodejs
$ nvm uninstall 16.13.1
</code></pre><blockquote><p>个人猜测是通过修改环境变量实现 node 版本切换</p></blockquote><p>在使用的时候遇到两个问题：</p><ol><li>安装老版本 nodejs  的时候，node 安装成功，但是 npm 安装失败；</li><li>使用 <code>nvm use</code> 切换 node 版本的时候报错；</li></ol><p>第一个问题，给 nvm 配置淘宝镜像即可解决。找到 nvm 安装目录下的 <code>settings.txt</code> 文件，添加配置：</p><pre><code class="language-bash">node_mirror: https://npm.taobao.org/mirrors/node/
npm_mirror: https://npm.taobao.org/mirrors/npm/
</code></pre><p>第二个问题，首先检查 nvm 安装路径没有中文、没有空格，然后如果问题还在，那就是权限问题，使用管理员权限打开 cmd 即可正常切换。</p><p>📒 获取 worker 线程最大并发数</p><p>通过下面的只读属性获取用户计算机的逻辑内核数：</p><pre><code class="language-javascript">logicalProcessors = window.navigator.hardwareConcurrency
</code></pre><p>下面的代码中，为每一个逻辑内核创建一个 worker 线程，充分利用 CPU 资源：</p><pre><code class="language-javascript">let workerList = [];

for (let i = 0; i &lt; window.navigator.hardwareConcurrency; i++) {
  let newWorker = {
    worker: new Worker(&#x27;cpuworker.js&#x27;),
    inUse: false
  };
  workerList.push(newWorker);
}
</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/hardwareConcurrency">Navigator.hardwareConcurrency - MDN</a></p><p>📒 <a href="https://juejin.cn/post/7039315081150087181">TypeScript类型中的逆变协变</a></p><p>📒 如何优雅引入 node 内置模块</p><p>在引用 node 内置模块的时候可以加 <code>node:</code> 前缀，比如：</p><pre><code class="language-javascript">import util from &#x27;node:util&#x27;;
import { promisify } from &#x27;node:util&#x27;;
import { spawn, exec } from &#x27;node:child_process&#x27;;
</code></pre><p>通过增加前缀，可以将 node 内置模块与其他第三方模块区分开：</p><pre><code class="language-javascript">import process from &#x27;node:process&#x27;;
import fs, {promises as fsPromises} from &#x27;node:fs&#x27;;
import path from &#x27;node:path&#x27;;
import parseJson from &#x27;parse-json&#x27;;
import normalizePackageData from &#x27;normalize-package-data&#x27;;
</code></pre><p>看到这边有同学会问，为啥 node 中可以使用 ES module，实际上现在 node 已经支持了 ES module ，只需要在 <code>package.json</code> 中设置如下字段即可：</p><pre><code class="language-javascript">{
    name: &quot;xxx&quot;,
    version: &quot;1.0.0&quot;
    type: &quot;module&quot;, // 默认 commonjs
}
</code></pre><p><a href="https://juejin.cn/post/7037270522236764167">从 vue-cli 源码中，我发现27行读取 json 文件有趣的 npm 包</a></p><p>📒 gradient-string: 在终端中输出漂亮的渐变色</p><p><img src="./gradient-string.png" alt="image"/></p><blockquote><p><a href="https://github.com/bokub/gradient-string">https://github.com/bokub/gradient-string</a></p></blockquote><p>📒 <a href="https://juejin.cn/post/6978654109893132318">手写系列-实现一个铂金段位的 React</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[12月5日内容汇总]]></title>
        <id>12月5日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/12月5日内容汇总"/>
        <updated>2021-12-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 如何切换后端环境]]></summary>
        <content type="html"><![CDATA[<p>📒 如何切换后端环境</p><p>在前端项目中，后端接口请求通常都通过 devServer 代理，这样解决了跨域问题。但是开发的时候经常需要切换后端环境，每次切换都要重启 devServer，这就导致每次都要重新构建，比较麻烦。</p><p>一种解决思路是，前端项目中后端接口地址使用 <strong>域名</strong>，在 <strong>系统 host 文件</strong> 中配置域名与 IP 地址的映射，这样每次切换后端环境，只需要修改系统 host 文件，然后在浏览器中刷新页面就可以实现切换。</p><p>但是每次手动修改 host 文件有点麻烦，可以使用 SwitchHost 工具，一键切换，非常方便。</p><p>📒 Vue 3 技术栈</p><ul><li>Vue3.2：核心库</li><li>Vite2.6：官方推出的基于 ESM 的构建工具</li><li>vue-router-next：Vue3 官方路由</li><li>pinia：官方推出的状态管理库</li><li>TypeScript：静态类型检查</li><li>Volar：Vue3 的 vscode 插件</li></ul><p>📒 Chrome 调试小技巧</p><p>在断点位置按 F9，可以一步一步往下执行，调试源码的时候查看调用栈特别有用。当然很多时候调用栈比较复杂，这时候通过 Performance 面板的火焰图看比较直观，火焰图的宽度代表执行耗时，火焰图的高度代表调用栈的深度。</p><p>📒 CommonJS 中的模块导出</p><p>CommonJS 规范中只有一种模块导出：<code>module.exports</code> ，而 <code>exports</code> 仅仅只是 <code>module.exports</code> 的引用而已</p><p>📒 推荐两个网站</p><ul><li><code>caniuse</code>：查询 api 兼容性</li><li><code>codeif</code>：变量命名</li></ul>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[11月28日内容汇总]]></title>
        <id>11月28日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/11月28日内容汇总"/>
        <updated>2021-11-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 叮咚，您有一份「前端项目开发规范」待查收！]]></summary>
        <content type="html"><![CDATA[<p>📒 <a href="https://juejin.cn/post/7033165869224034335">叮咚，您有一份「前端项目开发规范」待查收！</a></p><p>📒 <a href="https://juejin.cn/post/7033765500228206622">你了解 Browserslist 吗</a></p><p>📒 <a href="https://labuladong.github.io/algo/4/29/105/">回溯算法解题套路框架</a></p><p>📒 Golang 学习</p><ul><li><a href="https://gobyexample.com/">Golang 编程思维和工程实战</a></li><li>⭐️ <a href="https://gobyexample.com/">Go by example</a></li></ul><p>📒 React 文档翻译</p><ul><li><a href="https://reactjs.bootcss.com/learn/queueing-a-series-of-state-updates#challenges">Queueing a Series of State Updates</a></li><li><a href="https://github.com/reactjs/zh-hans.reactjs.org">React 中文文档</a></li></ul>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[11月21日内容汇总]]></title>
        <id>11月21日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/11月21日内容汇总"/>
        <updated>2021-11-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 垂直居中小技巧]]></summary>
        <content type="html"><![CDATA[<p>📒 垂直居中小技巧</p><p>相对父元素绝对定位，先向下偏移父元素高度的 <code>50%</code> ，在向上移动自身高度的 <code>50%</code> ：</p><pre><code class="language-css">.icon-common {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}
</code></pre><p>📒 <a href="https://juejin.cn/post/7030441979645263909">Git 几点小知识技巧</a></p><p>📒 <a href="https://juejin.cn/post/7025809061660590087">工程化知识卡片 014: 发包篇之 package.json 中 main、export、module 的区别何在</a></p><p>📒 第三方库如何解决潜在的间接依赖不可控问题</p><p><code>lockfile</code> 对于第三方库仍然必不可少，像 <code>react</code> 、<code>next.js</code> 、<code>webpack</code> 等均有 <code>yarn.lock</code> 。第三方库的 <code>devDependencies</code> 必须锁定，这样 Contributor 可根据 lockfile 很容易将项目跑起来。第三方库的 <code>dependencies</code> 有可能存在不可控问题，可参考 <code>next.js</code> 的解决方案：</p><ol><li><p>将依赖版本在 <code>package.json</code> 中锁死</p><pre><code class="language-javascript">{
    &quot;dependencies&quot;: {
        &quot;@babel/runtime&quot;: &quot;7.15.4&quot;,
        &quot;@hapi/accept&quot;: &quot;5.0.2&quot;,
        &quot;@napi-rs/triples&quot;: &quot;1.0.3&quot;
    }
}
</code></pre></li><li><p>将部分依赖直接编译后直接引入，而非通过依赖的方式；</p></li></ol><p>📒 语义化版本</p><p><code>semver</code>，<code>Semantic Versioning</code> 语义化版本的缩写，文档可见 semver.org/，它由 <code>[major, minor, patch]</code> 三部分组成，其中</p><ul><li><code>major</code>: 当你发了一个含有 Breaking Change 的 API</li><li><code>minor</code>:  当你新增了一个向后兼容的功能时</li><li><code>patch</code>: 当你修复了一个向后兼容的 Bug 时</li></ul><p>对于 <code>~1.2.3</code> 而言，它的版本号范围是 <code>&gt;=1.2.3  &lt;1.3.0</code>
对于 <code>^1.2.3</code> 而言，它的版本号范围是 <code>&gt;=1.2.3  &lt;2.0.0</code></p><p>当我们 <code>npm i</code> 时，默认的版本号是 <code>^</code>，可最大限度地在向后兼容与新特性之间做取舍，但是有些库有可能不遵循该规则，我们在项目时应当使用 <code>yarn.lock/package-lock.json</code> 锁定版本号。</p><p>📒 Vue 3.2 响应式优化相关</p><p><code>Object.defineProperty</code> 处理深度嵌套对象需要进行递归，而 <code>Proxy</code> 同样也只能监听当前层级的对象，如果深度嵌套也需要递归的，所以才有了 <code>reactive</code> 和 <code>shallowReactive</code> 。</p><p>之前看了黄轶老师写的 Vue3.2 响应式优化，<code>Proxy</code>  实际上比 <code>Object.defineProperty</code> 要慢，Vue 2.x 是直接在初始化阶段就进行深度递归，而 Vue3 的响应式优化就体现在只有访问对象属性的时候，再递归响应式，也就是延迟处理子对象，所以在初始化阶段性能较好。</p><p>📒 手把手实现一个 babel 插件</p><p>这篇做的 demo 是一个简单的 babel-plugin-import
<a href="https://juejin.cn/post/6844903746804137991">深入Babel，这一篇就够了</a></p><p>这篇做的 demo 类似 Java 中的 lambok
<a href="https://juejin.cn/post/7012424646247055390">保姆级教学！这次一定学会babel插件开发！</a></p><p>📒 <a href="https://juejin.cn/post/7025524870842679310#heading-58">从 16 个方向逐步搭建基于 vue3 的前端架构</a></p><p>📒 <a href="https://juejin.cn/post/6844903869558816781">VuePress + Travis CI + Github Pages 全自动上线文档</a></p>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[11月14日内容汇总]]></title>
        <id>11月14日内容汇总</id>
        <link href="https://your-docusaurus-test-site.com/frontend-weekly/blog/11月14日内容汇总"/>
        <updated>2021-11-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[📒 构建提效]]></summary>
        <content type="html"><![CDATA[<p>📒 构建提效</p><ul><li>打包工具：webpack -&gt; rollup</li><li>生成 AST ：babel -&gt; acorn</li><li>语法转换：babel -&gt; swc</li><li>代码压缩：terser -&gt; esbuild</li></ul><p>📒 代码规范相关</p><ul><li>ESLint 用于代码规范检查，在开发阶段提前规避问题，提升代码健壮性</li><li>Prettier 用于代码风格校验，统一团队编码风格</li></ul><blockquote><p>实际上编写文档、单元测试、类型声明、tsconfig.json 、ESLint 、Prettier 、lint-staged 、husky 这些对实现功能上来说没有任何作用，但是可以保障代码交付质量</p></blockquote><p>📒 生成自增 ID ：</p><p>看到一个通过 generator 函数生成自增 ID 的方法：</p><pre><code class="language-javascript">function *customIdGenerator() {
  let i = 0;
  while (true) {
    yield i++;
  }
}
</code></pre><p>看了下其实还可以通过闭包实现：</p><pre><code class="language-javascript">function customIdGenerator() {
  let i = 0;
  return {
    next() {
      return i++;
    }
  }
}

const IDGenerator = customIdGenerator();
IDGenerator.next(); // 0
IDGenerator.next(); // 1
IDGenerator.next(); // 2
IDGenerator.next(); // 3
IDGenerator.next(); // 4
IDGenerator.next(); // 5
</code></pre><p>:::tip</p><p>注意：</p><p><code>++i</code> 是先加再作为表达式的值去赋值，相当于 <code>(i = i + 1)</code></p><p><code>i++</code> 是先把原来的值作为表达式的值赋值再加</p><p>:::</p><p>📒 专业名词</p><p>缓存命中
规则命中
增量构建</p><p>📒 Promise 四种常用工具方法</p><ul><li><code>Promise.all()</code> ：接收一个 <code>Promise</code> 数组，如果所有 <code>Promise</code> 都 <code>fulfilled</code> 则返回结果数组，只要有一个 <code>Promise</code> 变为 <code>rejected</code> ，则返回最先 rejected 的 <code>Promise</code> ，通常<strong>用于并发请求</strong>；</li><li><code>Promise.race()</code> ：接收一个 <code>Promise</code> 数组，race 意思就是比谁快，返回状态最先改变的 <code>Promise</code> ，不管成功还是失败，通常<strong>用于请求超时处理</strong>；</li><li><code>Promise.any()</code> ：接收一个 <code>Promise</code> 数组，返回最先 <code>fulfilled</code> 的 <code>Promise</code> ，如果没有 <code>Promise</code> 状态转为 <code>fulfilled</code> ，则抛出一个 <code>AggregateError</code> ；</li><li><code>Promise.allSettled()</code> ：接收一个 <code>Promise</code> 数组，在所有 <code>Promise</code> 状态改变（<code>fulfilled</code> 或者 <code>rejected</code>）之后返回结果数组。<code>Promise.allSettled</code> 适用于异步任务互相不依赖，<code>Promise.all</code> 适用于异步任务互相之间需要依赖其他任务的结果；</li></ul><p>📒 什么时候不能使用箭头函数</p><ul><li>需要函数提升时（箭头函数只能写成表达式形式）；</li><li>需要使用函数的 <code>this</code> 、<code>arguments</code> 、<code>prototype</code> 时；</li><li>需要使用命名函数时（箭头函数是匿名的）；</li><li>需要作为构造函数时（箭头函数不能作为构造函数）；</li><li>需要在对象方法中访问当前对象时;</li></ul><pre><code class="language-javascript">let obj = {
  a: 1,
  fn1: () =&gt; {
    console.log(this)
  },
  fn2: function() {
    console.log(this)
  }
}
obj.fn1(); // Window
obj.fn2(); // {a: 1, fn1: ƒ, fn2: ƒ} ，这是 this 的隐式绑定

const f1 = obj.fn1;
const f2 = obj.fn2;
f1(); // Window
f2(); // Window ，隐式绑定取决于谁来调用，谁调用就指向谁
</code></pre><p>使用箭头函数之所以会指向 <code>Window</code> 是因为箭头函数等价于下面的代码：</p><pre><code class="language-javascript">var that = this; // 直接使用闭包缓存 this
let obj = {
  a: 1,
  fn1: function() {
        console.log(that);
    }
}
</code></pre><p>在对象方法（例如 Vue Options API）的异步回调中经常会遇到 <code>this</code> 丢失的情况，一般会使用闭包进行缓存：</p><pre><code class="language-javascript">// 使用 _this 变量进行缓存
const _this = this;
api.get(&quot;/api/xxx&quot;, function(res) {
    _this.tableData = res;
})

// 除了使用闭包缓存 this ，还可以使用箭头函数
api.get(&quot;/api/xxx&quot;, (res) =&gt; {
    this.tableData = res;
})
</code></pre><blockquote><p>总结一下：箭头函数没有自己的 <code>this</code> ，没有 <code>argument</code> 对象，没有 <code>prototype</code> ，不能作为构造函数（用 new 调用会报错）。箭头函数会自动捕获上级词法作用域的 <code>this</code> ，并且箭头函数的 <code>this</code> 在声明的时候就已经确定了，不能通过 <code>call</code> 或者 <code>apply</code> 修改</p></blockquote>]]></content>
        <author>
            <name>加菲猫</name>
            <uri>https://github.com/Jiacheng787</uri>
        </author>
    </entry>
</feed>